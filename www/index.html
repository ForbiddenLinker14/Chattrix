<!-- ওঁ নমো 

সিদ্ধিদাতা গণেশায় নমঃ                        সিদ্ধিদাতা গণেশায় নমঃ                                   সিদ্ধিদাতা গণেশায় নমঃ -->

<!DOCTYPE html>
<html lang="en">

<head>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7006477250957433"
    crossorigin="anonymous"></script>

  <link href="https://unpkg.com/cropperjs@1.5.13/dist/cropper.min.css" rel="stylesheet" />
  <script src="https://unpkg.com/cropperjs@1.5.13/dist/cropper.min.js"></script>

  <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>

  <meta name="google-site-verification" content="lvrePtNXjs6Q-t-SX8DeUld6iPEPqAFfLrUTcY_U2o4" />
  <link rel="icon" href="/icons/favicon.ico" type="image/png" />
  <meta charset="utf-8" />
  <link rel="manifest" href="/manifest.json" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, height=device-height" />
  <title>💬 Chattrix</title>
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="theme-color" content="#000000" />

  <style>
    html,
    body {
      height: 100%;
      /* Hide scrollbar (cross-browser) */
      scrollbar-width: none;
      /* Firefox */
      -ms-overflow-style: none;
      /* IE/Edge */
    }

    html::-webkit-scrollbar {
      display: none;
      /* Chrome, Safari, Opera */
    }

    body {
      font-family: Arial, sans-serif;
      margin: 0;
      display: flex;
      height: 100vh;
      /* lock app to viewport */
      overflow: auto;
      /* page itself never scrolls on desktop */
      background: #100e09;
      color: #eaeaea;
      /* Hide scrollbar (cross-browser) */
      scrollbar-width: none;
      /* Firefox */
      -ms-overflow-style: none;
      /* IE/Edge */
    }

    /* Landing page wrapper (intro + footer) */
    #intro-wrapper {
      max-width: 1000px;
      margin: auto;
      padding: 20px;
      line-height: 1.6;
    }

    /* Sidebar */
    #sidebar {
      width: 260px;
      background: #1a1812;
      padding: 15px;
      border-right: 1px solid #333;
      box-sizing: border-box;
      transition: transform 0.4s ease-in-out;
      position: relative;
      z-index: 2;
      color: #eaeaea;

      display: flex;
      flex-direction: column;
      height: 100vh;
      /* fixed column height */
    }

    #sidebar.hidden {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      transform: translateX(-100%);
    }

    #sidebar input[type="text"] {
      width: 100%;
      margin-bottom: 12px;
      padding: 8px 2px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      color: #fff;
      background: linear-gradient(145deg, #0d0d0d, #1a1a1a);
      box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.6),
        inset -2px -2px 5px rgba(50, 50, 50, 0.6);
      transition: all 0.3s;
    }

    #sidebar input[type="text"]::placeholder {
      color: #888;
    }

    #sidebar input[type="text"]:hover {
      background: linear-gradient(145deg, #1c1c1c, #2a2a2a);
    }

    #sidebar input[type="text"]:focus {
      outline: none;
      background: linear-gradient(145deg, #222, #333);
      box-shadow: 0 0 6px #25d366, inset 2px 2px 6px rgba(0, 0, 0, 0.7);
    }

    /* Chat container */
    #chat-container {
      flex: 1 1 0;
      display: flex;
      flex-direction: column;
      background: #100e09;
      min-height: 0;
      /* overflow: hidden; */
      /* allow internal scrollers */
    }

    /* Arrows */
    #show-arrow,
    #toggle-arrow {
      font-size: 18px;
      cursor: pointer;
      background: #256e4c;
      color: #eaeaea;
      padding: 4px 10px;
      border-radius: 4px;
      user-select: none;
      transition: background 0.3s;
    }

    #toggle-arrow {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 3;
    }

    #show-arrow {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 5;
      display: none;
    }

    #toggle-arrow:hover,
    #show-arrow:hover {
      background: #25d366;
    }

    /* Messages */
    #messages {
      flex: 1 1 0;
      padding: 15px;
      overflow-y: auto;
      background: #100e09;
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      -ms-overflow-style: none;
      min-height: 0;
      overscroll-behavior: contain;
      /* wheel doesn’t bubble to page */
    }

    #messages::-webkit-scrollbar {
      display: none;
    }

    .msg {
      margin: 5px 0;
      padding: 10px 14px;
      border-radius: 12px;
      max-width: 70%;
      word-wrap: break-word;
      font-size: 14px;
    }

    .msg.me {
      background: #032f30;
      color: #f1f1f1;
      margin-left: auto;
      text-align: right;
    }

    .msg.other {
      background: #0b4561;
      color: #f1f1f1;
      margin-right: auto;
      text-align: left;
    }

    .msg.system {
      display: block;
      width: 100% !important;
      max-width: 100% !important;
      text-align: center;
      color: #daedf7;
      font-style: italic;
      margin: 10px 0;
      box-sizing: border-box;
    }

    /* Input area */
    #input-area {
      display: flex;
      border-top: 1px solid #333;
      background: #1a1812;
    }

    #input {
      flex: 1;
      padding: 10px;
      border: none;
      font-size: 16px;
      background: #100e09;
      color: #eaeaea;
    }

    #input::placeholder {
      color: #777;
    }

    #attach {
      padding: 10px 15px;
      border: none;
      background: #2c3e50;
      color: white;
      cursor: pointer;
      font-size: 18px;
    }

    #attach:hover {
      background: #34495e;
    }

    #send {
      padding: 10px 20px;
      border: none;
      background: #27ae60;
      color: white;
      cursor: pointer;
      font-size: 16px;
    }

    #send:hover {
      background: #2ecc71;
    }

    /* Sidebar buttons */
    #sidebar button {
      margin-top: 5px;
      padding: 8px;
      border: none;
      cursor: pointer;
      border-radius: 6px;
      font-size: 14px;
    }

    #sidebar button:hover {
      opacity: 0.9;
    }

    #sidebar button:nth-child(3) {
      background: #e67e22;
      color: #fff;
    }

    #sidebar button:nth-child(4) {
      background: #c0392b;
      color: #fff;
    }

    #sidebar button:nth-child(5) {
      background: #e74c3c;
      color: #fff;
    }

    .username {
      font-weight: bold;
      margin-bottom: 4px;
    }

    .image-wrapper {
      position: relative;
      display: inline-block;
    }

    .image-wrapper img {
      max-width: 220px;
      border-radius: 8px;
      display: block;
    }

    .download-icon {
      position: absolute;
      top: 6px;
      right: 6px;
      background: rgba(0, 0, 0, 0.5);
      padding: 4px;
      border-radius: 4px;
      text-decoration: none;
      color: white;
      z-index: 10;
    }

    .download-icon:hover {
      background: rgba(0, 179, 84, 0.7);
    }

    .timestamp {
      font-size: 12px;
      color: #ccc;
      margin-top: 4px;
    }

    .image-wrapper video {
      max-width: 220px;
      border-radius: 8px;
      display: block;
      z-index: 1;
    }

    /* ===== Users panel & list (critical) ===== */
    #users-title {
      font-size: 16px;
      font-weight: bold;
      color: #f3f4f6;
      margin: 15px 0 10px;
      padding-bottom: 6px;
      border-bottom: 1px solid #333;
    }

    #users-panel {
      display: flex;
      flex-direction: column;
      flex: 1;
      /* always expand in sidebar */
      min-height: 0;
      /* allow user-list to shrink/scroll */
    }

    #user-list {
      flex: 1;
      min-height: 0;
      /* 👈 critical fix */
      overflow-y: auto;
      /* list scrolls, not body */
      overscroll-behavior: contain;

      list-style: none;
      padding: 0;
      margin: 0;
      background: #100e09;
      border: 1px solid #333;
      border-radius: 12px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);

      scrollbar-width: thin;
      scrollbar-color: #4b5563 #1a1813;

      /* HIDE scrollbar but keep scroll */
      scrollbar-width: none;
      /* Firefox */
      -ms-overflow-style: none;
      /* IE/Edge */
    }

    #user-list::-webkit-scrollbar {
      display: none;
      /* Chrome, Safari */
    }

    #user-list li {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 6px 10px;
      font-size: 14px;
      color: #e5e7eb;
      transition: background 0.2s;
      border-bottom: 1px solid #222;
    }

    #user-list li:hover {
      background: #1a1813;
      cursor: default;
    }

    /* Animations */
    #user-list li.fade-in {
      animation: fadeIn 0.4s ease forwards;
    }

    #user-list li.fade-out {
      animation: fadeOut 0.3s ease forwards;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(5px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
        transform: translateY(0);
      }

      to {
        opacity: 0;
        transform: translateY(-3px);
      }
    }

    #user-list::-webkit-scrollbar {
      width: 6px;
    }

    #user-list::-webkit-scrollbar-track {
      background: #1a1813;
      border-radius: 10px;
    }

    #user-list::-webkit-scrollbar-thumb {
      background: #4b5563;
      border-radius: 10px;
      border: 1px solid #1a1813;
    }

    #user-list::-webkit-scrollbar-thumb:hover {
      background: #6b7280;
    }

    /* Responsive mobile */
    @media (max-width: 768px) {
      body {
        flex-direction: column;
        overflow: auto;
      }

      #sidebar {
        width: 100%;
        border-right: none;
        border-bottom: 1px solid #333;
        height: auto;
      }

      /* Force list height cap on mobile */
      #users-panel {
        flex: none;
        max-height: 200px;
      }

      #user-list {
        max-height: 200px;
        overflow-y: auto;
      }
    }

    /* Gradient text title */
    .chat-title {
      font-size: 1.2em;
      cursor: pointer;
      display: inline-block;
      color: #43e97b;
      /* initial solid green */
      transition: color 0.3s ease;
    }

    /* On hover: switch to gradient shimmer */
    .chat-title:hover {
      background: linear-gradient(90deg,
          #4facfe,
          #00f2fe,
          #43e97b,
          #38f9d7,
          #4facfe);
      background-size: 300% auto;
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradientMove 3s linear infinite;
    }

    @keyframes gradientMove {
      0% {
        background-position: 0% center;
      }

      100% {
        background-position: 100% center;
      }
    }

    /* Add this CSS to hide elements immediately */
    #chat-container,
    #input-area,
    #messages {
      display: none;
    }

    /* Show intro by default */
    #intro {
      display: block;
    }

    /*after join flick fix */
    #intro,
    #chat-container,
    #input-area,
    #messages {
      display: none;
      /* all hidden until JS decides */
    }

    .cropper-bg {
      background: transparent !important;
    }

    .room-badge {
      float: right;
      background: #e74c3c;
      color: #fff;
      padding: 2px 6px;
      border-radius: 12px;
      font-size: 12px;
      min-width: 20px;
      text-align: center;
      display: none;
    }

    #joined-rooms-title {
      font-size: 16px;
      font-weight: bold;
      color: #f3f4f6;
      margin: 15px 0 10px;
      padding-bottom: 6px;
      border-bottom: 1px solid #333;
    }

    #joined-rooms {
      flex: 1;
      min-height: 0;
      /* 👈 allows shrinking inside flex */
      overflow-y: auto;
      /* scrollable like users */
      overscroll-behavior: contain;

      list-style: none;
      padding: 0;
      margin: 0;
      background: #100e09;
      border: 1px solid #333;
      border-radius: 12px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);

      /* scrollbar hidden but still scrollable */
      scrollbar-width: none;
      /* Firefox */
      -ms-overflow-style: none;
      /* IE/Edge */
    }

    #joined-rooms::-webkit-scrollbar {
      display: none;
      /* Chrome, Safari */
    }

    #joined-rooms li {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 6px 10px;
      font-size: 14px;
      color: #e5e7eb;
      transition: background 0.2s;
      border-bottom: 1px solid #222;
      cursor: pointer;
    }

    #joined-rooms li:hover {
      background: #1a1813;
    }

    #joined-rooms li.active {
      background: #256e4c;
      /* green highlight */
      color: #fff;
      font-weight: bold;
    }

    /* === Room ID + Lock toggle inline === */
    .room-id-container {
      display: flex;
      align-items: center;
      gap: 2px;
      /* spacing between Room ID and Lock */
      white-space: nowrap;
      /* prevents wrapping */
    }

    .room-id-label {
      color: #eaeaea;
      margin-right: 5px;
    }

    .lock-toggle-inline {
      display: flex;
      align-items: center;
      gap: 6px;
      /* spacing between Lock:, toggle, status */
      white-space: nowrap;
      /* keeps everything in one line */
    }

    /* === Toggle Switch (smaller) === */
    .lock-toggle {
      position: relative;
      display: inline-block;
      width: 36px;
      /* smaller width */
      height: 18px;
      /* smaller height */
      flex-shrink: 0;
      /* prevents shrinking */
    }

    .lock-toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .lock-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #e74c3c;
      transition: 0.3s;
      border-radius: 18px;
    }

    .lock-slider:before {
      position: absolute;
      content: "";
      height: 12px;
      /* knob smaller */
      width: 12px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    input:checked+.lock-slider {
      background-color: #27ae60;
    }

    input:checked+.lock-slider:before {
      transform: translateX(18px);
      /* knob shift for smaller toggle */
    }

    /* === Labels & Status === */
    .lock-label {
      color: #eaeaea;
    }

    .lock-status {
      font-size: 10px;
      color: #eaeaea;
      margin-left: 4px;
    }


    /* Add to your existing CSS */
    .admin-badge {
      font-size: 12px;
      animation: glow 2s ease-in-out infinite alternate;
    }

    @keyframes glow {
      from {
        text-shadow: 0 0 5px #ffd700;
      }

      to {
        text-shadow: 0 0 10px #ffd700, 0 0 15px #ffd700;
      }
    }

    #locked-room-alert {
      animation: fadeIn 0.3s ease-out;
    }

    #locked-room-alert button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(39, 174, 96, 0.4);
    }

    /* Join request notification styles */
    .msg.system.join-request {
      animation: pulse 2s infinite;
      max-width: 85% !important;
      margin: 15px auto !important;
    }

    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(230, 126, 34, 0.7);
      }

      70% {
        box-shadow: 0 0 0 10px rgba(230, 126, 34, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(230, 126, 34, 0);
      }
    }

    .join-request button {
      transition: all 0.3s ease;
    }

    .join-request button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    /* Alert System */
    .alert-overlay {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10000;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .alert {
      padding: 12px 20px;
      border-radius: 8px;
      color: white;
      font-weight: bold;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      animation: slideIn 0.3s ease, fadeOut 0.5s ease 1.5s forwards;
      min-width: 300px;
      text-align: center;
    }

    .alert.success {
      background: #27ae60;
      border-left: 4px solid #2ecc71;
    }

    .alert.error {
      background: #e74c3c;
      border-left: 4px solid #c0392b;
    }

    .alert.info {
      background: #3498db;
      border-left: 4px solid #2980b9;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeOut {
      to {
        opacity: 0;
        transform: translateY(-20px);
      }
    }

    .encrypted-indicator {
      font-size: 12px;
      color: #25d366;
      margin-left: 5px;
    }

    .msg.encrypted {
      border-left: 3px solid #25d366;
    }

    .encryption-status {
      padding: 10px;
      margin: 10px 0;
      background: #1a1812;
      border-radius: 8px;
      text-align: center;
      font-size: 14px;
    }

    .encryption-status.secure {
      border: 1px solid #25d366;
      color: #25d366;
    }

    .encryption-status.insecure {
      border: 1px solid #e74c3c;
      color: #e74c3c;
    }

    .msg.system.offline {
      background: #e74c3c !important;
      color: white !important;
      animation: pulse-offline 2s infinite;
    }

    .msg.system.online {
      background: #27ae60 !important;
      color: white !important;
    }

    @keyframes pulse-offline {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0.7;
      }

      100% {
        opacity: 1;
      }
    }

    .connection-status {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: bold;
      z-index: 1000;
      transition: all 0.3s ease;
    }

    .connection-status.online {
      background: #27ae60;
      color: white;
    }

    .connection-status.offline {
      background: #e74c3c;
      color: white;
      animation: pulse 2s infinite;
    }

    .connection-status.reconnecting {
      background: #f39c12;
      color: white;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0.6;
      }

      100% {
        opacity: 1;
      }
    }
  </style>
</head>

<body>
  <div id="show-arrow" onclick="toggleSidebar()">»</div>

  <div id="sidebar">
    <div id="toggle-arrow" onclick="toggleSidebar()">«</div>
    <h2 id="chat-title" class="chat-title" style="font-size: 1.2em; cursor: pointer">
      💬 Chattrix
    </h2>

    <label>Your Name:</label>
    <input id="name" type="text" placeholder="Your Name" />

    <div class="room-id-container">
      <label class="room-id-label">Room ID:</label>

      <!-- Lock toggle inline -->
      <div class="lock-toggle-inline">
        <label class="lock-label">🔒Lock:</label>
        <label class="lock-toggle">
          <input type="checkbox" id="roomLockToggle" onchange="toggleRoomLock()" />
          <span class="lock-slider"></span>
        </label>
        <span id="lockStatus" class="lock-status">Unlocked</span>
      </div>
    </div>

    <!-- Ad just above input -->
    <ins class="adsbygoogle" style="display: block; margin: 15px auto" data-ad-client="ca-pub-7006477250957433"
      data-ad-slot="9476713306" data-ad-format="auto" data-full-width-responsive="true"></ins>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
    </script>

    <input id="room" type="text" placeholder="Unique Personal Id" />

    <button onclick="joinRoom()" style="width: 100%">Enter</button>
    <button onclick="leaveRoom()" style="width: 100%; background: #ff9800; color: white">
      Leave Room
    </button>
    <button onclick="clearRoom()" style="width: 100%; background: #f44336; color: white">
      Clear Room
    </button>
    <button onclick="destroyRoom()" style="width: 100%; background: #eb3c06; color: white">
      Destroy Room
    </button>

    <div id="users-title">👥 Users</div>
    <div id="users-panel">
      <ul id="user-list"></ul>
    </div>

    <div id="joined-rooms-title">📂 Joined Rooms</div>
    <ul id="joined-rooms"></ul>
  </div>

  <!-- Intro Section -->
  <div id="intro" style="
        padding: 20px;
        background: #100e09;
        color: #eaeaea;
        max-width: 1000px;
        margin: auto;
        line-height: 1.6;
        text-align: center;
      ">
    <header style="
          background: #1a1812;
          padding: 20px;
          border-bottom: 1px solid #333;
        ">
      <h1 style="color: #25d366; margin: 0; text-align: center">
        Welcome to Chattrix – Connect Instantly With Friends
      </h1>
    </header>

    <p>
      <strong>Chattrix</strong> is a fast, secure, and easy-to-use chat
      platform where you can connect with your friends, family, or team
      instantly. Whether you’re on desktop or mobile, our chat app keeps you
      connected anytime, anywhere.
    </p>

    <p>
      Unlike traditional messaging apps, Chattrix runs directly in your
      browser, with no downloads required. Just enter your name, pick a room,
      and start chatting instantly!
    </p>

    <!-- blog2 -->
    <ins class="adsbygoogle" style="display: block" data-ad-client="ca-pub-7006477250957433" data-ad-slot="9197511706"
      data-ad-format="auto" data-full-width-responsive="true"></ins>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
    </script>

    <p>
      Our mission is to make communication simple, private, and accessible to
      everyone. With Chattrix, you don’t need to worry about complicated
      sign-ups, long installation processes, or heavy apps that slow down your
      device. Everything works instantly in your browser, making it
      lightweight and efficient. Whether you’re managing a study group,
      catching up with family, or collaborating with your team, Chattrix is
      built to keep conversations flowing smoothly.
    </p>

    <p>
      We believe in <strong>privacy-first communication</strong>. Unlike many
      messaging apps that collect user data, Chattrix respects your privacy.
      Your chats remain secure and are never shared with third parties. This
      makes our platform a safe space for casual users, professionals, and
      communities who value private and distraction-free conversations.
    </p>

    <p>
      Our platform is also <strong>constantly evolving</strong>. We are
      working on adding more features such as media sharing, customizable chat
      themes, and enhanced moderation tools for group conversations. By
      choosing Chattrix today, you’re joining a growing community that values
      fast, private, and reliable communication.
    </p>

    <!-- Three-column layout -->
    <div style="
          display: flex;
          justify-content: space-between;
          gap: 20px;
          margin-top: 20px;
          text-align: left;
          flex-wrap: wrap;
        ">
      <!-- Features -->
      <div style="flex: 1; min-width: 220px">
        <h2 style="color: #25d366; margin: 0 0 5px 0; font-size: 1.3em">
          ✨ Features
        </h2>
        <ul style="
              list-style: none;
              padding-left: 0;
              margin: 0;
              font-size: 0.95em;
            ">
          <li>✅ Instant real-time messaging</li>
          <li>✅ Private and group chats</li>
          <li>✅ Simple and clean interface</li>
          <li>✅ Free to use</li>
        </ul>
      </div>

      <!-- Why Choose Us -->
      <div style="flex: 1; min-width: 220px">
        <h2 style="color: #25d366; margin: 0 0 8px 0; font-size: 1.3em">
          💡 Why Choose Us?
        </h2>
        <p style="margin: 0; font-size: 0.95em">
          Unlike other chat apps, <strong>Chattrix</strong> doesn’t require
          sign-ups or downloads. It’s lightweight, privacy-friendly, and
          always available in your browser.
        </p>
      </div>

      <!-- FAQ -->
      <div style="flex: 1; min-width: 200px; font-size: 0.867em">
        <h2 style="color: #25d366; margin: 0 0 5px 0; font-size: 1.2em">
          📌 FAQ
        </h2>
        <ul style="list-style: disc; padding-left: 18px; margin: 0">
          <li><strong>Is it free?</strong> Yes, 100% free.</li>
          <li><strong>Is it safe?</strong> All chats stay private.</li>
          <li><strong>On mobile?</strong> Yes, works on all devices.</li>
          <li>
            <strong>Need download?</strong> No, works directly in browser.
          </li>
        </ul>
      </div>
    </div>
    <!-- Footer Section -->
    <footer style="
          margin-top: 30px;
          padding: 15px;
          background: #1a1812;
          color: #aaa;
          text-align: center;
          font-size: 0.9em;
          border-top: 1px solid #333;
          width: 100%;
          box-sizing: border-box;
        ">
      <div style="max-width: 900px; margin: 0 auto">
        <p>
          <a href="/about.html" style="color: #25d366; text-decoration: none; margin: 0 15px">About</a>
          |
          <a href="/privacy-policy.html" style="color: #25d366; text-decoration: none; margin: 0 15px">Privacy
            Policy</a>
          |
          <a href="/terms-of-service.html" style="color: #25d366; text-decoration: none; margin: 0 15px">Terms of
            Service</a>|
          <a href="/disclaimer.html" style="color: #25d366; text-decoration: none; margin: 0 15px">Disclaimer</a>
          |
          <a href="/blog.html" style="color: #25d366; text-decoration: none; margin: 0 15px">Blog</a>
          |
          <a href="/contact.html" style="color: #25d366; text-decoration: none; margin: 0 15px">Contact</a>
        </p>
        <p style="margin-top: 8px; font-size: 0.8em; color: #777">
          © 2025 Chattrix. All rights reserved.
        </p>
      </div>
    </footer>
  </div>

  <div id="chat-container">
    <div id="messages"></div>
    <div id="input-area">
      <input id="input" placeholder="Type your message…" disabled />
      <input type="file" id="fileInput" style="display: none" />
      <button id="attach" type="button" disabled>+</button>
      <button id="send" type="button" disabled>Send</button>
    </div>
  </div>

  <script>
    // ======================================================
    // =============== Fresh Install / Version Reset =========
    // ======================================================
    const APP_VERSION = "8.5";

    async function clearAllStorage() {
      console.log("🧹 Clearing old storage for version", APP_VERSION);
      try {
        localStorage.clear();
        sessionStorage.clear();

        document.cookie.split(";").forEach(cookie => {
          const name = cookie.split("=")[0].trim();
          document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/`;
        });

        if (window.indexedDB && indexedDB.databases) {
          try {
            const databases = await indexedDB.databases();
            databases.forEach(db => {
              if (db.name) indexedDB.deleteDatabase(db.name);
            });
          } catch (e) {
            console.warn("IndexedDB clear failed:", e);
          }
        }

        if (caches && caches.keys) {
          try {
            const cacheNames = await caches.keys();
            await Promise.all(cacheNames.map(name => caches.delete(name)));
          } catch (e) {
            console.warn("Cache Storage clear failed:", e);
          }
        }

        if (navigator.serviceWorker) {
          try {
            const registrations = await navigator.serviceWorker.getRegistrations();
            await Promise.all(registrations.map(registration => registration.unregister()));
          } catch (e) {
            console.warn("Service Worker clear failed:", e);
          }
        }

        try {
          const { Preferences } = await import('@capacitor/preferences');
          await Preferences.clear();
          console.log("✅ Capacitor Preferences cleared");
        } catch (err) {
          console.warn("⚠️ Preferences plugin not available or failed:", err);
        }

        console.log("✅ All storage cleared successfully");
      } catch (e) {
        console.warn("Storage clear partially failed:", e);
      }
    }

    (async function () {
      const lastVersion = localStorage.getItem("app_version");
      if (lastVersion !== APP_VERSION) {
        console.log(`🔄 Version change detected: ${lastVersion} -> ${APP_VERSION}`);
        await clearAllStorage();
        localStorage.setItem("app_version", APP_VERSION);
        setTimeout(() => {
          window.location.reload();
        }, 1000);
      } else {
        console.log(`✅ App version ${APP_VERSION} is current`);
      }
    })();

    // ======================================================
    // =============== Storage Utility ======================
    // ======================================================
    const Storage = {
      set(k, v) {
        try {
          localStorage.setItem(k, v);
          return;
        } catch { }
        try {
          sessionStorage.setItem(k, v);
          return;
        } catch { }
        document.cookie = `${k}=${encodeURIComponent(v)}; path=/`;
      },
      get(k) {
        try {
          return localStorage.getItem(k) || sessionStorage.getItem(k);
        } catch { }
        const m = document.cookie.match(new RegExp("(^| )" + k + "=([^;]+)"));
        return m ? decodeURIComponent(m[2]) : null;
      },
      remove(k) {
        try {
          localStorage.removeItem(k);
        } catch { }
        try {
          sessionStorage.removeItem(k);
        } catch { }
        document.cookie = `${k}=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT`;
      },
    };

    // ======================================================
    // =============== Push Notifications ===================
    // ======================================================
    const VAPID_PUBLIC_KEY = "BG2UPultjn00ejdUX4YQhGrQRPaJnLHA4n1afkUeni6YjsXnn-b9PInolQ-P79zvJD63LF5nZuI3iun0_TU81Lw";

    function urlBase64ToUint8Array(base64String) {
      const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
      const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");
      const rawData = atob(base64);
      return Uint8Array.from([...rawData].map((c) => c.charCodeAt(0)));
    }

    async function subscribeUser(sender, room) {
      const registration = await navigator.serviceWorker.ready;
      let subscription = await registration.pushManager.getSubscription();
      if (!subscription) {
        subscription = await registration.pushManager.subscribe({
          userVisibleOnly: true,
          applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY),
        });
      }
      localStorage.setItem("pushSub", JSON.stringify(subscription.toJSON()));
      const body = { sender: sender || "anonymous", room: room || null, subscription: subscription.toJSON() };
      const response = await fetch("/api/subscribe", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      });
      const result = await response.json();
      if (!response.ok) throw new Error(result?.error || "subscribe failed");
      return subscription;
    }

    async function unsubscribeUser(sender, room) {
      try {
        const savedSub = localStorage.getItem("pushSub");
        if (!savedSub) return;
        const subscription = JSON.parse(savedSub);
        await fetch("/api/unsubscribe", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ sender, room, subscription }),
        });
      } catch (err) {
        console.error("❌ Failed to unsubscribe:", err);
      }
    }

    async function requestNotificationPermission() {
      if (!("Notification" in window) || !("serviceWorker" in navigator)) return;
      const permission = await Notification.requestPermission();
      if (permission === "granted") {
        const registration = await navigator.serviceWorker.register("/sw.js");
      }
    }

    // ======================================================
    // =============== Chat Application State ===============
    // ======================================================
    let socket, currentRoom = "", currentName = "";
    let joinedRooms = new Set();
    let lastPersistedTs = null;
    let alreadyFetchingHistory = false;
    let sending = false;
    let roomTimestamps = {};
    let joinedRoomsByUser = {};
    let unreadCounts = {};
    let currentAdmin = null;
    let intentionalLeave = false;
    let isInitialConnection = true;
    let roomLockStates = {};
    const API_BASE = "https://realtime-chat-1mv3.onrender.com";

    // ======================================================
    // =============== Utility Functions ====================
    // ======================================================
    function escapeHtml(s) {
      return (s ?? "").replace(/[&<>"']/g, (c) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[c]));
    }

    function escapeAttr(s) {
      return escapeHtml(s).replace(/"/g, "&quot;");
    }

    function bumpTs(ts) {
      if (ts && (!lastPersistedTs || ts > lastPersistedTs)) lastPersistedTs = ts;
    }

    function sendActive(active) {
      if (socket) socket.emit("status", { active });
    }

    function showCopyNotice(text) {
      const messages = document.getElementById("messages");
      const div = document.createElement("div");
      div.className = "msg system";
      div.textContent = text;
      messages.appendChild(div);
      messages.scrollTo({ top: messages.scrollHeight, behavior: "smooth" });
      setTimeout(() => div.remove(), 2500);
    }

    let lastCopyTime = 0;
    function copyToClipboard(text, notice) {
      const now = Date.now();
      if (now - lastCopyTime < 400) return;
      lastCopyTime = now;
      navigator.clipboard.writeText(text).then(() => {
        if (notice) showCopyNotice(notice);
      }).catch((err) => console.error("❌ Copy failed:", err));
    }

    function enableCopyOnMessage(el, text) {
      el.style.userSelect = "none";
      let pressTimer;
      el.addEventListener("touchstart", () => {
        pressTimer = setTimeout(() => {
          copyToClipboard(text, "📋 Message copied");
        }, 500);
      });
      el.addEventListener("touchend", () => clearTimeout(pressTimer));
      el.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        copyToClipboard(text, "📋 Message copied");
      });
    }

    function enableCopyOnLink(el) {
      el.style.userSelect = "none";
      el.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        e.stopPropagation();
        copyToClipboard(el.href, "🔗 Link copied");
      });
      el.addEventListener("touchstart", (e) => {
        e.stopPropagation();
        const timer = setTimeout(() => {
          copyToClipboard(el.href, "🔗 Link copied");
        }, 500);
        el.addEventListener("touchend", () => clearTimeout(timer), { once: true });
      });
    }

    // function linkifyWithFavicon(text) {
    //   const urlRegex = /(https?:\/\/[^\s]+)/g;
    //   return text.replace(urlRegex, (url) => {
    //     try {
    //       const u = new URL(url);
    //       const favicon = `${u.origin}/favicon.ico`;
    //       return `<span style="display:inline-flex;align-items:center;gap:4px;user-select:none;">
    //     <img src="${favicon}" alt="icon" style="width:16px;height:16px;vertical-align:middle;border-radius:3px;user-select:none;">
    //     <a href="${url}" target="_blank" style="color:#4da6ff; text-decoration:underline; word-break:break-all; user-select:none;">${url}</a>
    //   </span>`;
    //     } catch {
    //       return `<a href="${url}" target="_blank" style="color:#4da6ff; text-decoration:underline; word-break:break-all; user-select:none;">${url}</a>`;
    //     }
    //   });
    // }
    // ✅ SECURE URL LINKIFY FUNCTION
    function linkifyWithFavicon(text) {
      const urlRegex = /(https?:\/\/[^\s]+)/g;
      return text.replace(urlRegex, (url) => {
        try {
          const u = new URL(url);
          // Only allow HTTP/HTTPS - CRITICAL SECURITY FIX
          if (!['http:', 'https:'].includes(u.protocol)) {
            return escapeHtml(url); // Block javascript:, data:, file: etc.
          }

          const favicon = `${u.origin}/favicon.ico`;
          return `<span style="display:inline-flex;align-items:center;gap:4px;user-select:none;">
        <img src="${escapeAttr(favicon)}" alt="icon" style="width:16px;height:16px;vertical-align:middle;border-radius:3px;user-select:none;">
        <a href="${escapeAttr(url)}" target="_blank" style="color:#4da6ff; text-decoration:underline; word-break:break-all; user-select:none;">${escapeHtml(url)}</a>
      </span>`;
        } catch {
          return `<a href="${escapeAttr(url)}" target="_blank" style="color:#4da6ff; text-decoration:underline; word-break:break-all; user-select:none;">${escapeHtml(url)}</a>`;
        }
      });
    }

    function showAlert(message, type = 'info') {
      let alertOverlay = document.getElementById('alert-overlay');
      if (!alertOverlay) {
        alertOverlay = document.createElement('div');
        alertOverlay.id = 'alert-overlay';
        alertOverlay.className = 'alert-overlay';
        document.body.appendChild(alertOverlay);
      }

      const alert = document.createElement('div');
      alert.className = `alert ${type}`;
      alert.textContent = message;
      alertOverlay.appendChild(alert);

      setTimeout(() => {
        if (alert.parentNode) alert.parentNode.removeChild(alert);
      }, 5000);
    }

    function showAdminActionError(error) {
      const messages = document.getElementById("messages");
      const errorDiv = document.createElement("div");
      errorDiv.className = "msg system";
      errorDiv.style.background = "#e74c3c";
      errorDiv.style.color = "white";
      errorDiv.innerHTML = `<strong>❌ Admin Action Failed</strong><br>${error}<br><small>${new Date().toLocaleString()}</small>`;
      messages.appendChild(errorDiv);
      messages.scrollTo({ top: messages.scrollHeight, behavior: "smooth" });
    }

    // ======================================================
    // =============== UI Functions =========================
    // ======================================================
    function toggleSidebar() {
      const sidebar = document.getElementById("sidebar");
      const showArrow = document.getElementById("show-arrow");
      if (sidebar.classList.contains("hidden")) {
        sidebar.classList.remove("hidden");
        showArrow.style.display = "none";
      } else {
        sidebar.classList.add("hidden");
        showArrow.style.display = "block";
      }
    }

    function updateLockUI(isLocked) {
      const lockStatus = document.getElementById("lockStatus");
      const toggle = document.getElementById("roomLockToggle");
      if (isLocked) {
        lockStatus.textContent = "Locked";
        lockStatus.style.color = "#e74c3c";
      } else {
        lockStatus.textContent = "Unlocked";
        lockStatus.style.color = "#27ae60";
      }
      toggle.checked = isLocked;
    }

    function updateAdminUI() {
      const lockContainer = document.querySelector('.lock-toggle-inline');
      const clearBtn = document.querySelector('button[onclick="clearRoom()"]');
      const destroyBtn = document.querySelector('button[onclick="destroyRoom()"]');
      const isAdmin = currentName === currentAdmin;

      console.log(`🔧 Admin UI Update: ${currentName} is admin? ${isAdmin}, Current admin: ${currentAdmin}`);

      if (lockContainer) {
        if (isAdmin) {
          lockContainer.style.display = 'flex';
          lockContainer.style.opacity = '1';
        } else {
          lockContainer.style.display = 'none';
        }
      }

      if (clearBtn) clearBtn.style.display = isAdmin ? 'block' : 'none';
      if (destroyBtn) destroyBtn.style.display = isAdmin ? 'block' : 'none';
      updateUserListWithAdmin();
    }

    function updateUserListWithAdmin() {
      const userList = document.getElementById("user-list");
      const items = userList.getElementsByTagName("li");
      for (let item of items) {
        const userName = item.getAttribute("data-name");
        const existingBadge = item.querySelector('.admin-badge');
        if (existingBadge) existingBadge.remove();
        if (userName === currentAdmin) {
          const adminBadge = document.createElement('span');
          adminBadge.className = 'admin-badge';
          adminBadge.textContent = ' 👑';
          adminBadge.style.marginLeft = '5px';
          adminBadge.style.color = '#ffd700';
          item.appendChild(adminBadge);
        }
      }
    }

    function showLockedRoomAlert(room, message) {
      closeLockedRoomAlert();
      const overlay = document.createElement("div");
      overlay.id = "locked-room-alert";
      overlay.style = `position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:10000;backdrop-filter:blur(5px);`;

      const alertBox = document.createElement("div");
      alertBox.style = `background:#1a1812;padding:25px;border-radius:16px;border:2px solid #e74c3c;max-width:400px;text-align:center;color:#eaeaea;box-shadow:0 10px 30px rgba(0,0,0,0.5);`;
      alertBox.innerHTML = `
    <div style="margin-bottom:20px;">
      <div style="font-size:48px;margin-bottom:10px;">🔒</div>
      <h3 style="color:#e74c3c;margin-top:0;margin-bottom:15px;">Room Locked</h3>
      <p style="margin:10px 0;line-height:1.5;">${message}</p>
      <p style="font-size:14px;color:#888;margin-top:15px;">Only the room admin can unlock this room.</p>
    </div>
    <button onclick="closeLockedRoomAlert()" style="background:#27ae60;color:white;border:none;padding:12px 24px;border-radius:8px;cursor:pointer;font-size:16px;transition:background 0.3s;" onmouseover="this.style.background='#2ecc71'" onmouseout="this.style.background='#27ae60'">OK</button>
  `;

      overlay.appendChild(alertBox);
      document.body.appendChild(overlay);
    }

    function closeLockedRoomAlert() {
      const alert = document.getElementById("locked-room-alert");
      if (alert) alert.remove();
    }

    function showJoinRequestNotification(request) {
      const messages = document.getElementById("messages");
      const notificationId = `join-request-${request.user}-${Date.now()}`;
      const notificationDiv = document.createElement("div");
      notificationDiv.id = notificationId;
      notificationDiv.className = "msg system join-request";
      notificationDiv.style.background = "#2c3e50";
      notificationDiv.style.border = "2px solid #e67e22";
      notificationDiv.style.padding = "15px";
      notificationDiv.style.textAlign = "center";
      notificationDiv.innerHTML = `
    <div style="margin-bottom:10px;"><strong>🔔 Join Request</strong></div>
    <div style="margin-bottom:15px;"><strong>${request.user}</strong> wants to join room <strong>"${request.room}"</strong></div>
    <div style="display:flex;gap:10px;justify-content:center;">
      <button onclick="approveJoinRequest('${request.room}','${request.user}')" style="background:#27ae60;color:white;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">✅ Approve</button>
      <button onclick="rejectJoinRequest('${request.room}','${request.user}')" style="background:#e74c3c;color:white;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">❌ Reject</button>
    </div>
    <div style="margin-top:10px;font-size:12px;color:#ccc;">${new Date(request.timestamp).toLocaleString()}</div>
  `;
      messages.appendChild(notificationDiv);
      messages.scrollTo({ top: messages.scrollHeight, behavior: "smooth" });
    }

    // ======================================================
    // =============== End-to-End Encryption ================
    // ======================================================
    class SignalProtocol {
      constructor() {
        this.identityKey = null;
        this.registrationId = null;
        this.preKeys = [];
        this.signedPreKey = null;
        this.sessions = {};
        this.pendingKeyExchange = {};
      }

      async initialize() {
        if (!this.identityKey) {
          this.identityKey = await this.generateKeyPair();
          this.registrationId = Math.floor(Math.random() * 16380) + 1;
          await this.generatePreKeys();
          await this.generateSignedPreKey();
          console.log("🔐 Signal protocol initialized");
        }
      }

      async generateKeyPair() {
        return await window.crypto.subtle.generateKey({ name: "ECDH", namedCurve: "P-256" }, true, ["deriveKey", "deriveBits"]);
      }

      async exportPublicKey(keyPair) {
        const publicKey = await window.crypto.subtle.exportKey("raw", keyPair.publicKey);
        return this.arrayBufferToBase64(publicKey);
      }

      async importPublicKey(publicKeyBase64) {
        if (!publicKeyBase64 || typeof publicKeyBase64 !== 'string') throw new Error("Invalid public key: must be a base64 string");
        if (publicKeyBase64.length < 10) throw new Error("Invalid public key: too short");
        const publicKeyBuffer = this.base64ToArrayBuffer(publicKeyBase64);
        return await window.crypto.subtle.importKey("raw", publicKeyBuffer, { name: "ECDH", namedCurve: "P-256" }, true, []);
      }

      async generatePreKeys() {
        this.preKeys = [];
        for (let i = 0; i < 10; i++) {
          const preKey = await this.generateKeyPair();
          const publicKey = await this.exportPublicKey(preKey);
          this.preKeys.push({ keyId: i, keyPair: preKey, publicKey: publicKey });
        }
      }

      async generateSignedPreKey() {
        this.signedPreKey = await this.generateKeyPair();
        this.signedPreKeyPublic = await this.exportPublicKey(this.signedPreKey);
      }

      async deriveSharedSecret(privateKey, publicKey) {
        const derivedBits = await window.crypto.subtle.deriveBits({ name: "ECDH", public: publicKey }, privateKey, 256);
        return new Uint8Array(derivedBits);
      }

      async hkdf(salt, ikm, info, length) {
        const key = await window.crypto.subtle.importKey("raw", ikm, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
        const prk = await window.crypto.subtle.sign("HMAC", key, salt);
        const infoBuffer = new TextEncoder().encode(info);
        const infoWithLength = new Uint8Array(infoBuffer.length + 1);
        infoWithLength.set(infoBuffer);
        infoWithLength[infoBuffer.length] = 0x01;
        const hmacKey = await window.crypto.subtle.importKey("raw", new Uint8Array(prk), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
        const okm = await window.crypto.subtle.sign("HMAC", hmacKey, infoWithLength);
        return new Uint8Array(okm).slice(0, length);
      }

      async startKeyExchange(recipientId, recipientPreKey) {
        const ephemeralKey = await this.generateKeyPair();
        const recipientPublicKey = await this.importPublicKey(recipientPreKey);
        const sharedSecret = await this.deriveSharedSecret(ephemeralKey.privateKey, recipientPublicKey);
        const rootKey = await this.hkdf(new Uint8Array(32).fill(0), sharedSecret, "Root Key Derivation", 32);
        const chainKey = await this.hkdf(rootKey, new Uint8Array(32).fill(0), "Chain Key Derivation", 32);
        this.sessions[recipientId] = { rootKey: rootKey, chainKey: chainKey, ephemeralKey: ephemeralKey, recipientPublicKey: recipientPublicKey, messageCount: 0 };
        const ephemeralPublicKey = await this.exportPublicKey(ephemeralKey);
        return { type: "key_exchange", senderId: currentName, ephemeralKey: ephemeralPublicKey, identityKey: await this.exportPublicKey(this.identityKey), preKeyId: 0 };
      }

      async completeKeyExchange(senderId, keyExchangeData) {
        const ephemeralKey = await this.importPublicKey(keyExchangeData.ephemeralKey);
        const senderIdentityKey = await this.importPublicKey(keyExchangeData.identityKey);
        const sharedSecret = await this.deriveSharedSecret(this.preKeys[0].keyPair.privateKey, ephemeralKey);
        const rootKey = await this.hkdf(new Uint8Array(32).fill(0), sharedSecret, "Root Key Derivation", 32);
        const chainKey = await this.hkdf(rootKey, new Uint8Array(32).fill(0), "Chain Key Derivation", 32);
        this.sessions[senderId] = { rootKey: rootKey, chainKey: chainKey, ephemeralKey: ephemeralKey, recipientPublicKey: senderIdentityKey, messageCount: 0 };
        this.saveSessions();
        console.log(`🔐 Session established with ${senderId}`);
      }

      async deriveMessageKeys(chainKey) {
        const messageKey = await this.hkdf(chainKey, new TextEncoder().encode("Message Key"), "Message Key Derivation", 32);
        const nextChainKey = await this.hkdf(chainKey, new TextEncoder().encode("Chain Key Step"), "Chain Key Derivation", 32);
        return { messageKey, nextChainKey };
      }

      async encryptMessage(recipientId, message) {
        const session = this.sessions[recipientId];
        if (!session) throw new Error(`No session established with ${recipientId}`);
        const { messageKey, nextChainKey } = await this.deriveMessageKeys(session.chainKey);
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const encodedMessage = new TextEncoder().encode(message);
        const cryptoKey = await window.crypto.subtle.importKey("raw", messageKey, { name: "AES-GCM" }, false, ["encrypt"]);
        const encrypted = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, cryptoKey, encodedMessage);
        session.chainKey = nextChainKey;
        session.messageCount += 1;
        this.saveSessions();
        return { ciphertext: this.arrayBufferToBase64(encrypted), iv: this.arrayBufferToBase64(iv), messageNumber: session.messageCount };
      }

      async decryptMessage(senderId, encryptedData) {
        const session = this.sessions[senderId];
        if (!session) throw new Error(`No session established with ${senderId}`);
        const { messageKey, nextChainKey } = await this.deriveMessageKeys(session.chainKey);
        const ciphertext = this.base64ToArrayBuffer(encryptedData.ciphertext);
        const iv = this.base64ToArrayBuffer(encryptedData.iv);
        const cryptoKey = await window.crypto.subtle.importKey("raw", messageKey, { name: "AES-GCM" }, false, ["decrypt"]);
        try {
          const decrypted = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, cryptoKey, ciphertext);
          session.chainKey = nextChainKey;
          session.messageCount += 1;
          this.saveSessions();
          return new TextDecoder().decode(decrypted);
        } catch (error) {
          throw new Error("Failed to decrypt message");
        }
      }

      base64ToArrayBuffer(base64) {
        try {
          const cleanBase64 = base64.replace(/[^A-Za-z0-9+/]/g, '');
          const binary = window.atob(cleanBase64);
          const bytes = new Uint8Array(binary.length);
          for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
          return bytes.buffer;
        } catch (error) {
          console.error("❌ Invalid base64 string:", base64);
          throw new Error("Invalid base64 encoding");
        }
      }

      arrayBufferToBase64(buffer) {
        try {
          const bytes = new Uint8Array(buffer);
          let binary = '';
          for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
          return window.btoa(binary);
        } catch (error) {
          console.error("❌ Error converting to base64:", error);
          throw new Error("Failed to convert to base64");
        }
      }

      getPublicKeyBundle() {
        return {
          identityKey: this.identityKey ? this.exportPublicKey(this.identityKey) : null,
          preKeys: this.preKeys.map(pk => ({ keyId: pk.keyId, publicKey: pk.publicKey })),
          signedPreKey: this.signedPreKeyPublic,
          registrationId: this.registrationId
        };
      }

      saveSessions() {
        try {
          const sessionData = {};
          Object.keys(this.sessions).forEach(userId => {
            const session = this.sessions[userId];
            sessionData[userId] = { rootKey: this.arrayBufferToBase64(session.rootKey), chainKey: this.arrayBufferToBase64(session.chainKey), messageCount: session.messageCount };
          });
          localStorage.setItem('signal_sessions', JSON.stringify(sessionData));
          console.log('💾 Encryption sessions saved');
        } catch (error) {
          console.error('❌ Failed to save sessions:', error);
        }
      }

      async loadSessions() {
        try {
          const saved = localStorage.getItem('signal_sessions');
          if (!saved) return;
          const sessionData = JSON.parse(saved);
          for (const [userId, data] of Object.entries(sessionData)) {
            try {
              this.sessions[userId] = {
                rootKey: this.base64ToArrayBuffer(data.rootKey),
                chainKey: this.base64ToArrayBuffer(data.chainKey),
                messageCount: data.messageCount || 0,
              };
            } catch (error) {
              console.warn(`⚠️ Failed to load session for ${userId}:`, error);
              delete this.sessions[userId];
            }
          }
          console.log('📂 Encryption sessions loaded');
        } catch (error) {
          console.error('❌ Failed to load sessions:', error);
        }
      }
    }

    const signalProtocol = new SignalProtocol();

    async function initializeEncryption() {
      try {
        await signalProtocol.initialize();
        await signalProtocol.loadSessions();
        console.log("🔐 End-to-end encryption initialized with persisted sessions");
        setTimeout(() => {
          restoreEncryptionStatusForMessages();
          updateEncryptionStatusOnReload();
        }, 1500);
        const sessionCount = Object.keys(signalProtocol.sessions).length;
        console.log(`📊 Loaded ${sessionCount} encryption sessions`);
      } catch (error) {
        console.error("❌ Failed to initialize encryption:", error);
      }
    }

    async function reestablishEncryptionSessions() {
      if (!currentRoom || !currentName) return;
      console.log("🔄 Re-establishing encryption sessions...");
      setTimeout(async () => {
        const users = getUsersFromUserList();
        const existingSessions = Object.keys(signalProtocol.sessions);
        console.log(`📋 Found ${users.length} users, ${existingSessions.length} existing sessions`);
        for (const userId of existingSessions) {
          if (users.includes(userId) && userId !== currentName) {
            console.log(`✅ Session with ${userId} is still valid`);
          } else {
            console.log(`🗑️ Removing stale session with ${userId}`);
            delete signalProtocol.sessions[userId];
          }
        }
        signalProtocol.saveSessions();
        for (const user of users) {
          if (user !== currentName && !signalProtocol.sessions[user]) {
            console.log(`🔑 Re-initiating key exchange with ${user}`);
            await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));
            try { await initiateKeyExchange(user); } catch (error) { console.warn(`⚠️ Key exchange with ${user} failed:`, error); }
          }
        }
      }, 3000);
    }

    function cleanupEncryptionSessions() {
      if (!currentRoom || !currentName) return;
      const userList = document.getElementById('user-list');
      const currentUsers = new Set();
      if (userList) {
        const userItems = userList.getElementsByTagName('li');
        for (let item of userItems) {
          const username = item.getAttribute('data-name');
          if (username) currentUsers.add(username);
        }
      }
      Object.keys(signalProtocol.sessions).forEach(userId => {
        if (!currentUsers.has(userId) && userId !== currentName) {
          console.log(`🧹 Removing session for user not in room: ${userId}`);
          delete signalProtocol.sessions[userId];
        }
      });
      signalProtocol.saveSessions();
    }

    async function sendEncryptedMessage() {
      if (sending) return;
      const inputEl = document.getElementById("input");
      const text = inputEl.value.trim();
      if (!text || !currentRoom) return;
      sending = true;
      document.getElementById("send").disabled = true;
      try {
        let finalPayload = { room: currentRoom, sender: currentName, text: text, ts: new Date().toISOString() };
        const userList = document.getElementById('user-list');
        const encryptedMessages = {};
        if (userList) {
          const userItems = userList.getElementsByTagName('li');
          for (let item of userItems) {
            const user = item.getAttribute('data-name');
            if (user && user !== currentName && signalProtocol.sessions[user]) {
              try {
                const encrypted = await signalProtocol.encryptMessage(user, text);
                encryptedMessages[user] = encrypted;
              } catch (error) {
                console.warn(`Could not encrypt for ${user}:`, error);
              }
            }
          }
        }
        if (Object.keys(encryptedMessages).length > 0) {
          finalPayload.encrypted = encryptedMessages;
          finalPayload.encryptionVersion = "signal-v1";
        }
        socket.emit("message", finalPayload, () => {
          sending = false;
          document.getElementById("send").disabled = false;
        });
        inputEl.value = "";
      } catch (error) {
        console.error("❌ Error sending encrypted message:", error);
        sending = false;
        document.getElementById("send").disabled = false;
      }
    }

    async function handleEncryptedMessage(data) {
      let displayText = data.text;
      let isEncrypted = false;
      if (data.encrypted && data.encrypted[currentName]) {
        try {
          const encryptedData = data.encrypted[currentName];
          displayText = await signalProtocol.decryptMessage(data.sender, encryptedData);
          isEncrypted = true;
        } catch (error) {
          console.error("❌ Failed to decrypt message:", error);
          displayText = "🔒 [Encrypted message - decryption failed]";
          isEncrypted = true;
        }
      } else if (signalProtocol.sessions && signalProtocol.sessions[data.sender]) {
        // Message might not have encrypted field but we have a session with sender
        isEncrypted = true;
      }
      const messages = document.getElementById("messages");
      const div = document.createElement("div");
      if (data.sender === "System") {
        div.className = "msg system";
        div.textContent = displayText;
      } else {
        const isMe = data.sender.toLowerCase() === currentName.toLowerCase();
        div.className = "msg " + (isMe ? "me" : "other");
        if (isEncrypted) div.classList.add("encrypted");
        const safeText = escapeHtml(displayText);
        const formattedText = linkifyWithFavicon(safeText);
        let lockIcon = "";
        if (isEncrypted) lockIcon = " 🔒";
        div.innerHTML = `<strong>${data.sender}${lockIcon}</strong><br>${formattedText}<br><small>${new Date(data.ts).toLocaleString()}</small>`;
        enableCopyOnMessage(div, displayText);
        div.querySelectorAll("a").forEach((a) => enableCopyOnLink(a));
      }
      messages.appendChild(div);
      messages.scrollTo({ top: messages.scrollHeight, behavior: "smooth" });
    }

    async function initiateKeyExchange(userId) {
      try {
        console.log(`🔑 Starting key exchange with ${userId}`);
        socket.emit("request_public_keys", { targetUser: userId, room: currentRoom, requester: currentName });
        console.log(`📤 Public key request sent to ${userId}`);
      } catch (error) {
        console.error("❌ Key exchange failed:", error);
      }
    }

    async function handleKeyExchange(data) {
      if (data.targetUser === currentName) {
        try {
          await signalProtocol.completeKeyExchange(data.senderId, data);
          console.log(`🔑 Key exchange completed with ${data.senderId}`);
          socket.emit("key_exchange_complete", { targetUser: data.senderId, room: currentRoom });
        } catch (error) {
          console.error("❌ Failed to complete key exchange:", error);
        }
      }
    }

    async function initializeRoomEncryption() {
      if (!currentRoom) return;
      console.log("🔑 Initializing room encryption...");
      setTimeout(async () => {
        const users = getUsersFromUserList();
        console.log(`🔑 Found ${users.length} users for key exchange`);
        for (const user of users) {
          if (user !== currentName && !signalProtocol.sessions[user]) {
            await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));
            try { await initiateKeyExchange(user); } catch (error) { console.warn(`⚠️ Key exchange with ${user} failed:`, error); }
          }
        }
      }, 3000);
    }

    function getUsersFromUserList() {
      const userList = document.getElementById('user-list');
      const users = [];
      if (userList) {
        const userItems = userList.getElementsByTagName('li');
        for (let item of userItems) {
          const username = item.getAttribute('data-name');
          if (username) users.push(username);
        }
      }
      return users;
    }

    function updateEncryptionStatusOnReload() {
      const messages = document.getElementById("messages");
      const messageDivs = messages.querySelectorAll('.msg:not(.system)');
      messageDivs.forEach(div => {
        const isEncrypted = div.querySelector('strong')?.textContent?.includes('🔒');
        if (!isEncrypted && signalProtocol.sessions) {
          const senderElement = div.querySelector('strong');
          if (senderElement) {
            const senderName = senderElement.textContent.replace('🔒', '').trim();
            const isMe = senderName === currentName || senderName.includes('(Me)');
            if (senderName !== currentName && signalProtocol.sessions[senderName]) {
              senderElement.textContent = isMe ? `${currentName} 🔒` : `${senderName} 🔒`;
            }
          }
        }
      });
      console.log("🔒 Updated encryption status for existing messages");
    }

    function restoreEncryptionStatusForMessages() {
      const messages = document.getElementById("messages");
      if (!messages) return;
      const messageDivs = messages.querySelectorAll('.msg:not(.system)');
      messageDivs.forEach(div => {
        const senderElement = div.querySelector('strong');
        if (!senderElement) return;
        // Extract sender name (remove lock icon if present)
        let senderName = senderElement.textContent.replace('🔒', '').trim();
        // Remove "(Me)" suffix if present
        if (senderName.endsWith('(Me)')) {
          senderName = senderName.slice(0, -4).trim();
        }
        const isMe = senderName === currentName;
        // Check if we have an encryption session with this sender
        if (!isMe && signalProtocol.sessions && signalProtocol.sessions[senderName]) {
          // Add encryption indicator if not already present
          if (!senderElement.textContent.includes('🔒')) {
            senderElement.textContent = isMe ? `${currentName} 🔒` : `${senderName} 🔒`;
            div.classList.add('encrypted');
          }
        }
      });
      console.log("🔒 Restored encryption status for existing messages");
    }

    function debugEncryption() {
      console.group("🔐 Encryption Debug Info");
      console.log("Identity Key:", signalProtocol.identityKey ? "✓ Generated" : "✗ Missing");
      console.log("Pre-keys:", signalProtocol.preKeys.length);
      console.log("Active Sessions:", Object.keys(signalProtocol.sessions));
      Object.keys(signalProtocol.sessions).forEach(userId => {
        const session = signalProtocol.sessions[userId];
        console.log(`  - ${userId}: messageCount=${session.messageCount}`);
      });
      console.log("Current Room:", currentRoom);
      console.log("Current User:", currentName);
      const savedSessions = localStorage.getItem('signal_sessions');
      console.log("Saved sessions in localStorage:", savedSessions ? JSON.parse(savedSessions) : "None");
      console.groupEnd();
    }

    // ======================================================
    // =============== Room Management ======================
    // ======================================================
    async function joinRoom() {
      currentName = document.getElementById("name").value.trim();
      currentRoom = document.getElementById("room").value.trim();
      if (!currentName || !currentRoom) {
        alert("Enter name and room first!");
        return;
      }
      Storage.remove("pending_room");
      Storage.remove("pending_name");
      if (joinedRooms.has(currentRoom)) {
        alert(`You are already in room "${currentRoom}"!`);
        return;
      }
      const isLocked = await checkRoomLockStatus(currentRoom);
      let roomUsers = [];
      if (isLocked) {
        roomUsers = await getRoomUsers(currentRoom);
        const isExistingUser = roomUsers.includes(currentName);
        if (!isExistingUser) {
          await sendJoinRequest(currentRoom, currentName);
          return;
        }
      }
      await initializeEncryption();
      const waitForUserList = setInterval(() => {
        const userList = document.getElementById('user-list');
        if (userList && userList.getElementsByTagName('li').length > 0) {
          clearInterval(waitForUserList);
          setTimeout(() => initializeRoomEncryption(), 2000);
        }
      }, 500);
      setTimeout(() => clearInterval(waitForUserList), 10000);
      await proceedWithJoin(currentRoom, currentName);
    }

    async function sendJoinRequest(room, username) {
      console.log("🔄 Establishing connection for join request...");
      showAlert("Connecting to server...", "info");
      if (socket) {
        socket.off();
        socket.disconnect();
        socket = null;
      }
      document.getElementById("chat-container").style.display = "flex";
      document.getElementById("input-area").style.display = "none";
      document.getElementById("intro").style.display = "none";
      document.getElementById("messages").style.display = "block";
      document.getElementById("messages").innerHTML = "";
      addMessage({ sender: "System", text: `Connecting to server and sending join request for room "${room}"...`, ts: new Date().toISOString() });
      socket = io("https://realtime-chat-1mv3.onrender.com", { path: "/socket.io", transports: ["websocket"], timeout: 10000 });
      Storage.set("pending_room", room);
      Storage.set("pending_name", username);
      setupJoinRequestSocketHandlers();
      let requestSent = false;
      let connectionTimeout;
      socket.on("connect", () => {
        console.log("🔗 Connected to server (waiting for admin)");
        clearTimeout(connectionTimeout);
        showAlert("Connected to server. Sending join request...", "info");
        addMessage({ sender: "System", text: `Connected! Sending join request to room admin...`, ts: new Date().toISOString() });
        if (!requestSent) {
          requestSent = true;
          const fcmToken = localStorage.getItem("fcm_token") || null;
          socket.emit("join", { room: room, sender: username, lastTs: null, fcmToken: fcmToken }, (ack) => {
            if (ack && ack.error === "room_locked") {
              console.log("⏳ Join request sent to admin - waiting for approval");
              showAlert("Join request sent to admin. Waiting for approval...", "info");
              addMessage({ sender: "System", text: `Join request for room "${room}" sent to admin. Waiting for approval...`, ts: new Date().toISOString() });
            } else if (ack && ack.success) {
              console.log("✅ Unexpected immediate join - proceeding");
              proceedWithJoin(room, username);
            } else {
              console.error("❌ Join request failed:", ack);
              showAlert("Failed to send join request. Please try again.", "error");
              addMessage({ sender: "System", text: `Failed to send join request: ${ack?.error || 'Unknown error'}`, ts: new Date().toISOString() });
              setTimeout(() => {
                document.getElementById("chat-container").style.display = "none";
                document.getElementById("input-area").style.display = "none";
                document.getElementById("intro").style.display = "block";
              }, 3000);
            }
          });
        }
      });
      socket.on("connect_error", (error) => {
        console.error("❌ Connection failed:", error);
        clearTimeout(connectionTimeout);
        showAlert("Failed to connect to server. Please try again.", "error");
        addMessage({ sender: "System", text: `Connection failed: ${error.message || 'Unknown error'}`, ts: new Date().toISOString() });
        socket = null;
        setTimeout(() => {
          document.getElementById("chat-container").style.display = "none";
          document.getElementById("input-area").style.display = "none";
          document.getElementById("intro").style.display = "block";
        }, 3000);
      });
      connectionTimeout = setTimeout(() => {
        if (!requestSent) {
          console.error("⏰ Connection timeout");
          showAlert("Connection timeout. Please try again.", "error");
          addMessage({ sender: "System", text: "Connection timeout. Please try again.", ts: new Date().toISOString() });
          if (socket) {
            socket.disconnect();
            socket = null;
          }
          setTimeout(() => {
            document.getElementById("chat-container").style.display = "none";
            document.getElementById("input-area").style.display = "none";
            document.getElementById("intro").style.display = "block";
          }, 3000);
        }
      }, 10000);
    }

    function setupJoinRequestSocketHandlers() {
      if (!socket) return;
      socket.on("join_request_sent", (data) => {
        console.log("📨 Server confirmed join request received");
        addMessage({ sender: "System", text: data.message, ts: new Date().toISOString() });
      });
      socket.on("join_approved", (data) => {
        console.log("✅ Join request approved by admin");
        showAlert("Join request approved! Joining room...", "success");
        Storage.remove("pending_room");
        Storage.remove("pending_name");
        addMessage({ sender: "System", text: data.message, ts: new Date().toISOString() });
        setTimeout(() => proceedWithJoin(currentRoom, currentName), 1500);
      });
      socket.on("join_rejected", (data) => {
        console.log("❌ Join request rejected by admin");
        showAlert("Join request was rejected by admin", "error");
        Storage.remove("pending_room");
        Storage.remove("pending_name");
        addMessage({ sender: "System", text: data.message, ts: new Date().toISOString() });
        if (socket) {
          socket.disconnect();
          socket = null;
        }
        setTimeout(() => {
          document.getElementById("chat-container").style.display = "none";
          document.getElementById("input-area").style.display = "none";
          document.getElementById("intro").style.display = "block";
        }, 2000);
      });
      socket.on("pending_requests", (data) => {
        console.log(`📋 Received ${data.requests.length} pending requests`);
        if (data.room === currentRoom && currentName === currentAdmin) {
          data.requests.forEach(request => showJoinRequestNotification(request));
        }
      });
      socket.on("disconnect", (reason) => {
        console.log("🔌 Socket disconnected:", reason);
        if (reason === "io server disconnect" && !Storage.get("pending_room")) {
          console.log("🔄 Attempting to reconnect...");
          socket.connect();
        } else console.log(`🔌 Normal disconnect: ${reason}`);
      });
    }

    async function proceedWithJoin(room, username) {
      isInitialConnection = true;
      const roomStatus = await checkRoomStatus(room, username);
      if (roomStatus.destroyed) {
        if (roomStatus.time_remaining <= 0) closeDestroyedRoomAlert();
        else showDestroyedRoomAlert(room, roomStatus.time_remaining);
        return;
      } else closeDestroyedRoomAlert();
      Storage.set("chat_name", username);
      Storage.set("chat_room", room);
      document.getElementById("chat-container").style.display = "flex";
      document.getElementById("input-area").style.display = "flex";
      document.getElementById("intro").style.display = "none";
      document.getElementById("messages").style.display = "block";
      document.getElementById("messages").innerHTML = "";
      lastPersistedTs = null;
      alreadyFetchingHistory = false;
      document.getElementById("input").disabled = false;
      document.getElementById("send").disabled = false;
      document.getElementById("attach").disabled = false;
      document.getElementById("user-list").innerHTML = "";
      if (socket) {
        socket.off();
        socket.disconnect();
      }
      socket = io("https://realtime-chat-1mv3.onrender.com", { path: "/socket.io", transports: ["websocket"], reconnection: true, reconnectionAttempts: 10, reconnectionDelay: 1000, reconnectionDelayMax: 5000, timeout: 10000 });
      setupSocketEventHandlers();
      subscribeUser(username, room).catch((err) => console.warn("⚠️ Subscription failed in joinRoom:", err));
      function safeJoinWithRetry(attempt = 1) {
        if (!socket || !socket.connected) return;
        if (joinedRooms.has(room)) return;
        const fcmToken = localStorage.getItem("fcm_token") || null;
        socket.emit("join", { room: room, sender: username, lastTs: lastPersistedTs || null, fcmToken: fcmToken }, (ack) => {
          if (ack && ack.success) {
            joinedRooms.add(room);
            sendActive(!document.hidden);
            const isLocked = roomLockStates[room];
            if (isLocked !== undefined) {
              document.getElementById("roomLockToggle").checked = isLocked;
              updateLockUI(isLocked);
            }
          } else {
            if (ack && ack.error === 'room_locked') console.log("Room is locked during normal join");
            else setTimeout(() => safeJoinWithRetry(attempt + 1), 500);
          }
        });
      }
      socket.on("connect", () => {
        console.log("🔗 Connected to server");
        const messagesEl = document.getElementById("messages");
        if (messagesEl) messagesEl.innerHTML = "";
        lastPersistedTs = null;
        alreadyFetchingHistory = false;
        document.getElementById("input").disabled = false;
        document.getElementById("send").disabled = false;
        document.getElementById("attach").disabled = false;
        if (currentRoom && currentName) {
          const fcmToken = localStorage.getItem("fcm_token") || null;
          socket.emit("join", { room: currentRoom, sender: currentName, lastTs: null, fcmToken: fcmToken }, (ack) => {
            if (ack && ack.success) {
              joinedRooms.add(currentRoom);
              sendActive(!document.hidden);
              fetchUnreadCounts();
              if (currentName === currentAdmin) {
                socket.emit("get_pending_requests", { room: currentRoom, user: currentName });
              }// Restore encryption status after messages are loaded
              setTimeout(() => { restoreEncryptionStatusForMessages(); }, 1000);
              if (!isInitialConnection) {
                const messages = document.getElementById("messages");
                if (messages) {
                  const onlineDiv = document.createElement("div");
                  onlineDiv.className = "msg system online";
                  onlineDiv.innerHTML = `<strong>✅ Reconnected</strong><br>You're back online!<br><small>${new Date().toLocaleString()}</small>`;
                  messages.appendChild(onlineDiv);
                  messages.scrollTo({ top: messages.scrollHeight, behavior: "smooth" });
                  setTimeout(() => { if (onlineDiv.parentNode) onlineDiv.remove(); }, 3000);
                }
              }
              isInitialConnection = false;
            } else {
              console.error("❌ Rejoin failed:", ack);
              setTimeout(() => {
                if (socket && socket.connected) {
                  socket.disconnect();
                  socket.connect();
                }
              }, 1000);
            }
          });
        } else restoreChatState(socket);
      });
      socket.on("disconnect", (reason) => {
        console.log("🔌 Socket disconnected:", reason);
        if (!intentionalLeave) {
          document.getElementById("input").disabled = true;
          document.getElementById("send").disabled = true;
          document.getElementById("attach").disabled = true;
          const messages = document.getElementById("messages");
          if (messages) {
            const offlineDiv = document.createElement("div");
            offlineDiv.className = "msg system";
            offlineDiv.style.background = "#e74c3c";
            offlineDiv.style.color = "white";
            offlineDiv.innerHTML = `<strong>🔌 Connection Lost</strong><br>Attempting to reconnect...<br><small>${new Date().toLocaleString()}</small>`;
            messages.appendChild(offlineDiv);
            messages.scrollTo({ top: messages.scrollHeight, behavior: "smooth" });
          }
        }
      });
      socket.on("reconnect_attempt", (attemptNumber) => console.log(`🔄 Reconnect attempt ${attemptNumber}`));
      socket.on("reconnect_failed", () => {
        console.log("❌ Reconnect failed");
        const messages = document.getElementById("messages");
        if (messages) {
          const failedDiv = document.createElement("div");
          failedDiv.className = "msg system";
          failedDiv.style.background = "#c0392b";
          failedDiv.style.color = "white";
          failedDiv.innerHTML = `<strong>❌ Connection Failed</strong><br>Please check your internet connection and refresh the page.<br><small>${new Date().toLocaleString()}</small>`;
          messages.appendChild(failedDiv);
          messages.scrollTo({ top: messages.scrollHeight, behavior: "smooth" });
        }
      });
      const joinedList = document.getElementById("joined-rooms");
      if (![...joinedList.children].some((li) => li.dataset.room === room)) {
        const li = document.createElement("li");
        li.textContent = room;
        li.dataset.room = room;
        li.style.padding = "6px 10px";
        li.style.cursor = "pointer";
        li.onclick = () => switchRoom(room);
        joinedList.appendChild(li);
      }
      joinedRoomsByUser = JSON.parse(localStorage.getItem("joinedRoomsByUser") || "{}");
      if (!joinedRoomsByUser[username]) joinedRoomsByUser[username] = [];
      if (!joinedRoomsByUser[username].includes(room)) {
        joinedRoomsByUser[username].push(room);
        localStorage.setItem("joinedRoomsByUser", JSON.stringify(joinedRoomsByUser));
      }
      renderJoinedRooms();
      setTimeout(() => reestablishEncryptionSessions(), 4000);
    }

    function setupSocketEventHandlers() {
      if (!socket) return;
      socket.on("room_permanently_destroyed", (data) => {
        Storage.remove("chat_name");
        Storage.remove("chat_room");
        if (joinedRoomsByUser[currentName]) {
          joinedRoomsByUser[currentName] = joinedRoomsByUser[currentName].filter((r) => r !== data.room);
          localStorage.setItem("joinedRoomsByUser", JSON.stringify(joinedRoomsByUser));
        }
        document.getElementById("chat-container").style.display = "none";
        document.getElementById("input-area").style.display = "none";
        document.getElementById("intro").style.display = "block";
        document.getElementById("messages").innerHTML = "";
        document.getElementById("user-list").innerHTML = "";
        currentRoom = "";
        renderJoinedRooms();
      });
      socket.on("join_request", (data) => {
        if (currentName === currentAdmin && data.room === currentRoom) showJoinRequestNotification(data);
      });
      socket.on("key_exchange", handleKeyExchange);
      socket.on("key_exchange_complete", (data) => console.log(`🔑 Key exchange confirmed with ${data.senderId}`));
      socket.on("request_public_keys", async (data) => {
        console.log(`🔑 Received public key request from ${data.requester}`);
        const keyBundle = signalProtocol.getPublicKeyBundle();
        socket.emit("send_public_keys", { requester: data.requester, room: data.room, sender: currentName, keyBundle: keyBundle });
      });
      socket.on("receive_public_keys", async (data) => {
        console.log(`🔑 Received public keys from ${data.sender}`);
        try {
          const preKey = data.keyBundle.preKeys[0];
          const keyExchangeData = await signalProtocol.startKeyExchange(data.sender, preKey.publicKey);
          socket.emit("key_exchange", { targetUser: data.sender, room: currentRoom, ...keyExchangeData });
          console.log(`🔑 Key exchange initiated with ${data.sender}`);
        } catch (error) { console.error("❌ Key exchange failed:", error); }
      });
      socket.on("key_exchange_error", (data) => console.error(`❌ Key exchange error: ${data.error} for user ${data.targetUser}`));
      socket.on("pending_requests", (data) => {
        if (data.room === currentRoom && currentName === currentAdmin) data.requests.forEach(request => showJoinRequestNotification(request));
      });
      socket.on("room_admin_update", (data) => {
        if (data.room === currentRoom) {
          currentAdmin = data.admin;
          updateAdminUI();
          if (data.locked !== undefined) {
            roomLockStates[currentRoom] = data.locked;
            document.getElementById("roomLockToggle").checked = data.locked;
            updateLockUI(data.locked);
          }
        }
      });
      socket.on("room_locked_alert", (data) => showLockedRoomAlert(data.room, data.message));
      socket.on("users_update", updateUserList);
      socket.on("left_room", (data) => { if (data.room === currentRoom) document.getElementById("user-list").innerHTML = ""; });
      socket.on("room_destroyed", handleRoomDestroyed);
      socket.on("clear", handleRoomCleared);
      socket.on("clear_room_from_storage", (data) => {
        const roomToClear = data.room;
        const savedRoom = Storage.get("chat_room");
        if (savedRoom === roomToClear) {
          Storage.remove("chat_name");
          Storage.remove("chat_room");
        }
        const currentName = Storage.get("chat_name") || currentName;
        if (currentName && joinedRoomsByUser[currentName]) {
          joinedRoomsByUser[currentName] = joinedRoomsByUser[currentName].filter((r) => r !== roomToClear);
          localStorage.setItem("joinedRoomsByUser", JSON.stringify(joinedRoomsByUser));
        }
        if (currentRoom === roomToClear) {
          currentRoom = "";
          document.getElementById("chat-container").style.display = "none";
          document.getElementById("input-area").style.display = "none";
          document.getElementById("intro").style.display = "block";
          document.getElementById("messages").innerHTML = "";
          document.getElementById("user-list").innerHTML = "";
        }
        renderJoinedRooms();
      });
      socket.on("room_lock_changed", (data) => {
        if (data.room === currentRoom) {
          roomLockStates[data.room] = data.locked;
          document.getElementById("roomLockToggle").checked = data.locked;
          updateLockUI(data.locked);
          addMessage({ sender: "System", text: `Room has been ${data.locked ? "locked" : "unlocked"} by ${data.lockedBy}`, ts: new Date().toISOString() });
        }
      });
      socket.on("room_message_meta", (data) => {
        try {
          if (!currentName) return;
          joinedRoomsByUser = joinedRoomsByUser || JSON.parse(localStorage.getItem("joinedRoomsByUser") || "{}");
          const myRooms = joinedRoomsByUser[currentName] || [];
          if (!myRooms.includes(data.room)) return;
          if (data.room === currentRoom) return;
          unreadCounts[data.room] = (unreadCounts[data.room] || 0) + 1;
          saveUnread();
          updateBadge(data.room);
          const title = `Room ${data.room}`;
          const body = `${data.sender}: ${data.text}`;
          if ("Notification" in window && Notification.permission === "granted") {
            try {
              const n = new Notification(title, { body, tag: `room-${data.room}` });
              n.onclick = () => { window.focus(); switchRoom(data.room); n.close(); };
            } catch (e) { console.warn("Notification failed:", e); }
          } else {
            const original = document.title;
            document.title = `${data.room}: ${data.sender}`;
            setTimeout(() => (document.title = original), 2500);
          }
        } catch (err) { console.warn("room_message_meta handler err:", err); }
      });
      socket.on("message", handleEncryptedMessage);
      socket.on("file", addFileMessage);
      document.getElementById("send").onclick = sendMessage;
      document.getElementById("input").onkeydown = (e) => {
        if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendMessage(); }
      };
      document.getElementById("attach").onclick = (e) => { e.preventDefault(); document.getElementById("fileInput").click(); };
      document.getElementById("fileInput").onchange = handleFileUpload;
    }

    async function checkRoomStatus(room, user) {
      try {
        const q = user ? `?user=${encodeURIComponent(user)}` : "";
        const response = await fetch(`${API_BASE}/room-status/${encodeURIComponent(room)}${q}`);
        if (!response.ok) throw new Error("Failed to check room status");
        const status = await response.json();
        return status;
      } catch (err) {
        console.warn("Room status check failed:", err);
        return { destroyed: true, was_destroyed: true, time_remaining: 0 };
      }
    }

    function showDestroyedRoomAlert(room, initialTimeRemaining) {
      let timeRemaining = Math.floor(initialTimeRemaining);
      closeDestroyedRoomAlert();
      const overlay = document.createElement("div");
      overlay.id = "destroyed-room-alert";
      overlay.style = `position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:10000;`;
      let messageHtml;
      if (timeRemaining > 0) {
        messageHtml = `<p>Room <strong>"${room}"</strong> is currently destroyed.</p><p>Please wait <span id="countdown-timer" style="font-weight:bold;color:#25d366;">${timeRemaining}</span> seconds before trying again.</p><p style="font-size:12px;color:#888;">Auto-join will be available when timer reaches 0.</p>`;
      } else {
        messageHtml = `<p>Room <strong>"${room}"</strong> was previously destroyed.</p><p>Auto-join is blocked. You can manually join the room.</p><p style="font-size:12px;color:#888;">Checking server status every 10 seconds...</p>`;
      }
      const alertBox = document.createElement("div");
      alertBox.style = `background:#1a1812;padding:20px;border-radius:12px;border:2px solid #e74c3c;max-width:400px;text-align:center;color:#eaeaea;`;
      alertBox.innerHTML = `<h3 style="color:#e74c3c;margin-top:0;">🚫 Room Destroyed</h3>${messageHtml}<button onclick="closeDestroyedRoomAlert()" style="background:#27ae60;color:white;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;margin-top:10px;">Close</button>`;
      overlay.appendChild(alertBox);
      document.body.appendChild(overlay);
      overlay._room = room;
      const countdownEl = document.getElementById("countdown-timer");
      let countdownInterval;
      if (timeRemaining > 0 && countdownEl) {
        countdownInterval = setInterval(() => {
          timeRemaining--;
          countdownEl.textContent = timeRemaining;
          if (timeRemaining <= 0) {
            clearInterval(countdownInterval);
            countdownEl.textContent = "0";
            countdownEl.style.color = "#e74c3c";
            countdownEl.closest("p").innerHTML = "Auto-join is now available!";
          }
        }, 1000);
      }
      const statusCheckInterval = setInterval(async () => {
        try {
          const status = await checkRoomStatus(room);
          if (!status.destroyed && !status.was_destroyed) {
            if (countdownInterval) clearInterval(countdownInterval);
            clearInterval(statusCheckInterval);
            closeDestroyedRoomAlert();
          } else if (status.destroyed && countdownEl && status.time_remaining) {
            const serverTimeRemaining = Math.floor(status.time_remaining);
            if (serverTimeRemaining !== timeRemaining) {
              timeRemaining = serverTimeRemaining;
              countdownEl.textContent = serverTimeRemaining;
              if (serverTimeRemaining <= 0) countdownEl.style.color = "#e74c3c";
              else countdownEl.style.color = "#25d366";
            }
          }
        } catch (err) { console.warn("Room status check failed:", err); }
      }, 10000);
      overlay._intervals = [countdownInterval, statusCheckInterval].filter(Boolean);
    }

    function closeDestroyedRoomAlert() {
      const alert = document.getElementById("destroyed-room-alert");
      if (alert && alert._intervals) alert._intervals.forEach(clearInterval);
      if (alert) alert.remove();
    }

    async function syncDestroyedRooms() {
      try {
        const res = await fetch(`${API_BASE}/destroyed_rooms`, { cache: "no-store" });
        if (!res.ok) { console.warn("syncDestroyedRooms: server returned", res.status); return; }
        const data = await res.json();
        const destroyed = data.destroyed || [];
        if (destroyed.length && currentName) {
          joinedRoomsByUser = joinedRoomsByUser || JSON.parse(localStorage.getItem("joinedRoomsByUser") || "{}");
          joinedRoomsByUser[currentName] = (joinedRoomsByUser[currentName] || []).filter((room) => !destroyed.includes(room));
          localStorage.setItem("joinedRoomsByUser", JSON.stringify(joinedRoomsByUser));
          if (destroyed.includes(currentRoom)) {
            currentRoom = "";
            document.getElementById("chat-container").style.display = "none";
            document.getElementById("input-area").style.display = "none";
            document.getElementById("intro").style.display = "block";
            document.getElementById("messages").innerHTML = "";
            document.getElementById("user-list").innerHTML = "";
          }
        }
      } catch (err) { console.warn("Failed to sync destroyed rooms:", err); }
    }

    // ======================================================
    // =============== Badge Management =====================
    // ======================================================
    function unreadKey() { return "unreadCounts_" + (currentName || "anon"); }

    function loadUnread() {
      try { unreadCounts = JSON.parse(localStorage.getItem(unreadKey()) || "{}"); } catch (e) { unreadCounts = {}; }
    }

    function saveUnread() {
      try { localStorage.setItem(unreadKey(), JSON.stringify(unreadCounts)); } catch (e) { }
    }

    function updateBadge(room) {
      const list = document.getElementById("joined-rooms");
      if (!list) return;
      const li = [...list.children].find((x) => x.dataset.room === room);
      if (!li) return;
      let badge = li.querySelector(".room-badge");
      if (!badge) {
        badge = document.createElement("span");
        badge.className = "room-badge";
        badge.style.cssText = "float:right;background:#e74c3c;color:#fff;padding:2px 6px;border-radius:12px;font-size:12px;min-width:20px;text-align:center;display:inline-block";
        li.appendChild(badge);
      }
      const count = unreadCounts[room] || 0;
      badge.textContent = count > 0 ? (count > 99 ? "99+" : count) : "";
      badge.style.display = count > 0 ? "inline-block" : "none";
    }

    async function fetchUnreadCounts() {
      if (!currentName || !socket || !socket.connected) return;
      try {
        const response = await fetch(`${API_BASE}/unread-counts?user=${encodeURIComponent(currentName)}`);
        if (response.ok) {
          const data = await response.json();
          if (data.unreadCounts) {
            Object.keys(data.unreadCounts).forEach((room) => {
              unreadCounts[room] = (unreadCounts[room] || 0) + data.unreadCounts[room];
            });
            saveUnread();
            const rooms = joinedRoomsByUser[currentName] || [];
            rooms.forEach((room) => updateBadge(room));
          }
        }
      } catch (err) { console.warn("Failed to fetch unread counts:", err); }
    }

    // ======================================================
    // =============== Joined Rooms Management ==============
    // ======================================================
    function renderJoinedRooms() {
      loadUnread();
      const list = document.getElementById("joined-rooms");
      list.innerHTML = "";
      const rooms = joinedRoomsByUser[currentName] || [];
      rooms.forEach((room) => {
        const li = document.createElement("li");
        li.dataset.room = room;
        li.className = "joined-room-item";
        if (room === currentRoom) li.classList.add("active");
        const span = document.createElement("span");
        span.className = "room-name";
        span.textContent = room;
        li.appendChild(span);
        const badge = document.createElement("span");
        badge.className = "room-badge";
        li.appendChild(badge);
        li.onclick = () => switchRoom(room);
        list.appendChild(li);
        updateBadge(room);
      });
    }

    function switchRoom(room) {
      if (!room || room === currentRoom) return;
      const previousRoom = currentRoom;
      const messagesEl = document.getElementById("messages");
      const usersEl = document.getElementById("user-list");
      messagesEl && (messagesEl.innerHTML = "");
      usersEl && (usersEl.innerHTML = "");
      currentRoom = room;
      lastPersistedTs = null;
      document.getElementById("room").value = currentRoom;
      Storage.set("chat_room", currentRoom);
      Array.from(document.getElementById("joined-rooms").children).forEach((li) => {
        li.style.background = li.dataset.room === currentRoom ? "#256e4c" : "transparent";
      });
      if (previousRoom && socket && socket.connected) {
        try { socket.emit("leave", { room: previousRoom, sender: currentName, reason: "switch" }); } catch (e) { console.warn("Failed to emit leave for previous room:", e); }
      }
      if (!socket || !socket.connected) { joinRoom(); return; }
      socket.emit("join", { room: currentRoom, sender: currentName, lastTs: null }, (ack) => {
        if (ack && ack.success) {
          joinedRooms.add(currentRoom);
          joinedRoomsByUser[currentName] = joinedRoomsByUser[currentName] || [];
          if (!joinedRoomsByUser[currentName].includes(currentRoom)) {
            joinedRoomsByUser[currentName].push(currentRoom);
            localStorage.setItem("joinedRoomsByUser", JSON.stringify(joinedRoomsByUser));
          }
          renderJoinedRooms();
          document.getElementById("chat-container").style.display = "flex";
          document.getElementById("input-area").style.display = "flex";
          document.getElementById("intro").style.display = "none";
          document.getElementById("messages").style.display = "block";
        }
      });
      unreadCounts[currentRoom] = 0;
      saveUnread();
      updateBadge(currentRoom);
    }

    async function restoreChatState(socket) {
      const state = await loadChatState();
      if (state) {
        const messagesEl = document.getElementById("messages");
        if (messagesEl) messagesEl.innerHTML = "";
        lastPersistedTs = null;
        document.getElementById("input").disabled = false;
        document.getElementById("send").disabled = false;
        document.getElementById("attach").disabled = false;
        const fcmToken = localStorage.getItem("fcm_token") || null;
        socket.emit("join", { room: state.room, sender: state.username, lastTs: null, fcmToken: fcmToken });
      }
    }

    // ======================================================
    // =============== Message Handling =====================
    // ======================================================
    async function sendMessage() { await sendEncryptedMessage(); }

    function addMessage(data) {
      const messages = document.getElementById("messages");
      if (data.ts) roomTimestamps[currentRoom] = data.ts;
      const div = document.createElement("div");
      if (data.sender === "System") {
        div.className = "msg system";
        div.textContent = data.text;
        enableCopyOnMessage(div, data.text);
      } else {
        bumpTs(data.ts);
        const isMe = data.sender.toLowerCase() === currentName.toLowerCase();
        div.className = "msg " + (isMe ? "me" : "other");
        div.dataset.ts = data.ts;

        // Check if this message was originally encrypted
        const wasEncrypted = data.encrypted && data.encrypted[currentName];
        const isEncrypted = wasEncrypted || (signalProtocol.sessions && signalProtocol.sessions[data.sender]);

        let displayText = data.text;

        // If encrypted and we have the session, try to decrypt
        if (wasEncrypted && signalProtocol.sessions && signalProtocol.sessions[data.sender]) {
          try {
            const encryptedData = data.encrypted[currentName];
            displayText = signalProtocol.decryptMessage(data.sender, encryptedData);
          } catch (error) {
            console.error("❌ Failed to decrypt historical message:", error);
            displayText = "🔒 [Encrypted message - decryption failed]";
          }
        }

        const safeText = escapeHtml(data.text);
        const formattedText = linkifyWithFavicon(safeText);
        let lockIcon = "";
        if (isEncrypted) {
          lockIcon = " 🔒";
          div.classList.add("encrypted");
        }
        div.innerHTML = `<strong>${data.sender}</strong><br>${formattedText}<br><small>${new Date(data.ts).toLocaleString()}</small>`;
        enableCopyOnMessage(div, displayText);
        div.querySelectorAll("a").forEach((a) => enableCopyOnLink(a));
      }
      messages.appendChild(div);
      messages.scrollTo({ top: messages.scrollHeight, behavior: "smooth" });
    }

    // ======================================================
    // =============== File Handling ========================
    // ======================================================
    async function saveFileToDevice(base64Data, filename, mimeType) {
      try {
        const cleaned = base64Data.includes(",") ? base64Data.split(",")[1] : base64Data;
        const { Filesystem, Toast } = window.Capacitor.Plugins;
        if (!Filesystem) {
          if (Toast) await Toast.show({ text: "❌ Filesystem plugin missing!", duration: "short", position: "bottom" });
          return;
        }
        const result = await Filesystem.writeFile({ path: filename, data: cleaned, directory: "DOCUMENTS" });
        if (Toast) await Toast.show({ text: `✅ Downloaded: ${filename}`, duration: "short", position: "bottom" });
        return result.uri;
      } catch (e) {
        const { Toast } = window.Capacitor.Plugins;
        if (Toast) await Toast.show({ text: `❌ Save failed: ${e.message}`, duration: "short", position: "bottom" });
      }
    }

    window.downloadFile = async (base64, filename, mimetype) => {
      try {
        if (window.Capacitor?.isNativePlatform()) await saveFileToDevice(base64, filename, mimetype);
        else { const a = document.createElement("a"); a.href = base64; a.download = filename; a.click(); }
      } catch (err) {
        const { Toast } = window.Capacitor.Plugins;
        if (Toast) await Toast.show({ text: `❌ Download error: ${err.message}`, duration: "short", position: "bottom" });
      }
    };

    function base64ToBlob(base64Data, contentType = "") {
      const parts = base64Data.split(",");
      const byteCharacters = atob(parts[1]);
      const byteNumbers = new Array(byteCharacters.length);
      for (let i = 0; i < byteCharacters.length; i++) byteNumbers[i] = byteCharacters.charCodeAt(i);
      const byteArray = new Uint8Array(byteNumbers);
      return new Blob([byteArray], { type: contentType });
    }

    function generateVideoThumbnail(videoUrl, callback) {
      const video = document.createElement("video");
      video.src = videoUrl;
      video.crossOrigin = "anonymous";
      video.load();
      video.addEventListener("loadeddata", () => { video.currentTime = 1; });
      video.addEventListener("seeked", () => {
        const canvas = document.createElement("canvas");
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const imageUrl = canvas.toDataURL();
        callback(imageUrl);
      });
    }

    async function generatePdfThumbnail(pdfUrl, callback) {
      const pdfjsLib = window["pdfjs-dist/build/pdf"];
      pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";
      const loadingTask = pdfjsLib.getDocument(pdfUrl);
      const pdf = await loadingTask.promise;
      const page = await pdf.getPage(1);
      const viewport = page.getViewport({ scale: 1 });
      const canvas = document.createElement("canvas");
      const context = canvas.getContext("2d");
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      await page.render({ canvasContext: context, viewport: viewport }).promise;
      const thumbnailUrl = canvas.toDataURL("image/png");
      callback(thumbnailUrl);
    }

    window.addFileMessage = function addFileMessage(data) {
      bumpTs(data.ts);
      const div = document.createElement("div");
      const isMe = data.sender.toLowerCase() === currentName.toLowerCase();
      div.className = "msg " + (isMe ? "me" : "other");
      div.dataset.ts = data.ts;
      if (data.mimetype && data.mimetype.startsWith("image/")) {
        div.innerHTML = `<div class="username"><strong>${data.sender}</strong></div>
      <div class="image-wrapper">
        <a href="javascript:void(0)" onclick="downloadFile('${data.data}','${escapeAttr(data.filename)}','${data.mimetype}')" class="download-icon" title="Download">
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="white" viewBox="0 0 24 24"><path d="M12 16l4-5h-3V4h-2v7H8l4 5zM5 18h14v2H5v-2z"/></svg>
        </a>
        <img src="${data.data}" alt="${escapeAttr(data.filename)}" style="cursor:pointer;">
      </div>
      <div class="timestamp"><small>${new Date(data.ts).toLocaleString()}</small></div>`;
      } else if (data.mimetype && data.mimetype.startsWith("video/")) {
        const videoBlob = base64ToBlob(data.data, data.mimetype);
        const videoUrl = URL.createObjectURL(videoBlob);
        generateVideoThumbnail(videoUrl, (thumbnailUrl) => {
          div.innerHTML = `<div class="username"><strong>${data.sender}</strong></div>
        <div class="image-wrapper">
          <a href="javascript:void(0)" onclick="downloadFile('${data.data}','${escapeAttr(data.filename)}','${data.mimetype}')" class="download-icon" title="Download">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="white" viewBox="0 0 24 24"><path d="M12 16l4-5h-3V4h-2v7H8l4 5zM5 18h14v2H5v-2z"/></svg>
          </a>
          <img src="${thumbnailUrl}" style="max-width:220px;cursor:pointer;" onclick="openPreview('${videoUrl}','${data.mimetype}','${data.filename}')">
        </div>
        <div class="timestamp"><small>${new Date(data.ts).toLocaleString()}</small></div>`;
        });
      } else if (data.mimetype === "application/pdf") {
        const pdfBlob = base64ToBlob(data.data, data.mimetype);
        const pdfUrl = URL.createObjectURL(pdfBlob);
        generatePdfThumbnail(pdfUrl, (thumbnailUrl) => {
          div.innerHTML = `<div class="username"><strong>${data.sender}</strong></div>
        <div class="image-wrapper">
          <a href="javascript:void(0)" onclick="downloadFile('${data.data}','${escapeAttr(data.filename)}','${data.mimetype}')" class="download-icon" title="Download">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="white" viewBox="0 0 24 24"><path d="M12 16l4-5h-3V4h-2v7H8l4 5zM5 18h14v2H5v-2z"/></svg>
          </a>
          <img src="${thumbnailUrl}" style="width:220px;height:150px;object-fit:cover;cursor:pointer;border-radius:8px;" onclick="openPreview('${pdfUrl}','${data.mimetype}','${data.filename}')">
          <div style="margin-top:4px;font-size:12px;color:#fff;text-align:center;">📄 ${data.filename}</div>
        </div>
        <div class="timestamp"><small>${new Date(data.ts).toLocaleString()}</small></div>`;
        });
      }
      const messages = document.getElementById("messages");
      messages.appendChild(div);
      messages.scrollTo({ top: messages.scrollHeight, behavior: "smooth" });
      try {
        if (data.mimetype && data.mimetype.startsWith("image/")) {
          const img = div.querySelector("img");
          if (img) {
            img.dataset.mimetype = data.mimetype || "";
            img.dataset.filename = data.filename || "";
            img.addEventListener("click", (e) => {
              try { openPreview(img.src, img.dataset.mimetype || data.mimetype, img.dataset.filename || data.filename); } catch (err) { console.error("DEBUG_PREVIEW", "error in img click handler", err); }
            });
          }
        } else if (data.mimetype && data.mimetype.startsWith("video/")) {
          const video = div.querySelector("video");
          if (video) {
            video.dataset.mimetype = data.mimetype || "";
            video.dataset.filename = data.filename || "";
            video.addEventListener("click", (e) => {
              try { openPreview(video.querySelector("source").src, video.dataset.mimetype || data.mimetype, video.dataset.filename || data.filename); } catch (err) { console.error("DEBUG_PREVIEW", "error in video click handler", err); }
            });
          }
        } else if (data.mimetype === "application/pdf") {
          const link = div.querySelector(".download-link");
          if (link) {
            link.addEventListener("click", (e) => {
              e.preventDefault();
              try { openPreview(data.data, data.mimetype, data.filename); } catch (err) { console.error("DEBUG_PREVIEW", "error in pdf click handler", err); }
            }, { passive: false });
          }
        }
      } catch (err) { console.error("DEBUG_PREVIEW", "attach handler general error:", err); }
    };

    // ======================================================
    // =============== Preview Functions ====================
    // ======================================================
    async function openPreview(src, type, filename) {
      try {
        if (!src) return;
        if (document.getElementById("preview-overlay")) return;
        const overlay = document.createElement("div");
        overlay.id = "preview-overlay";
        overlay.style = `position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);display:flex;align-items:center;justify-content:center;z-index:99999;padding:12px;box-sizing:border-box;`;
        const box = document.createElement("div");
        box.style = `background:#fff;border-radius:8px;max-width:95%;max-height:95%;overflow:hidden;padding:8px;box-sizing:border-box;display:flex;flex-direction:column;align-items:center;`;
        const header = document.createElement("div");
        header.style = "width:100%;display:flex;align-items:center;justify-content:space-between;padding:6px 8px;box-sizing:border-box;";
        const title = document.createElement("div");
        title.textContent = filename || "Preview";
        title.style = "font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;";
        header.appendChild(title);
        box.appendChild(header);
        const contentWrapper = document.createElement("div");
        contentWrapper.style = `width:100%;flex:1 1 auto;overflow:auto;display:flex;flex-direction:column;align-items:center;gap:12px;padding:8px 6px;box-sizing:border-box;`;
        box.appendChild(contentWrapper);
        const controls = document.createElement("div");
        controls.style = "width:100%;display:flex;justify-content:flex-end;margin-top:8px;";
        const closeBtn = document.createElement("button");
        closeBtn.textContent = "Close";
        closeBtn.onclick = closePreview;
        closeBtn.style = "background:#e74c3c;color:#fff;padding:6px 12px;border:none;border-radius:4px;cursor:pointer;";
        controls.appendChild(closeBtn);
        box.appendChild(controls);
        overlay.appendChild(box);
        document.body.appendChild(overlay);
        overlay.addEventListener("click", (ev) => { if (ev.target === overlay) closePreview(); });
        const onKey = (ev) => { if (ev.key === "Escape") closePreview(); };
        window.addEventListener("keydown", onKey);
        const onPop = () => { closePreview(); };
        history.pushState({ preview: true }, "");
        window.addEventListener("popstate", onPop);
        overlay._cleanup = () => {
          window.removeEventListener("keydown", onKey);
          window.removeEventListener("popstate", onPop);
        };
        if (type && type.startsWith("image/")) {
          const img = document.createElement("img");
          img.src = src;
          img.alt = filename || "image";
          img.style.maxWidth = "100%";
          img.style.maxHeight = "80vh";
          img.style.borderRadius = "6px";
          contentWrapper.appendChild(img);
          return;
        }
        if (type === "application/pdf" || (typeof src === "string" && src.startsWith("data:application/pdf"))) {
          const loadingIndicator = document.createElement("div");
          loadingIndicator.textContent = "Loading PDF…";
          loadingIndicator.style = "color:#333;padding:8px;";
          contentWrapper.appendChild(loadingIndicator);
          try {
            const pdfjsLib = window["pdfjs-dist/build/pdf"];
            pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";
            const loadingTask = pdfjsLib.getDocument(src);
            const pdf = await loadingTask.promise;
            loadingIndicator.remove();
            const maxDisplayWidth = Math.min(window.innerWidth * 0.9, 1200);
            for (let p = 1; p <= pdf.numPages; p++) {
              const page = await pdf.getPage(p);
              const viewport = page.getViewport({ scale: 1 });
              const devicePixelRatio = window.devicePixelRatio || 1;
              const targetCssWidth = Math.min(viewport.width, maxDisplayWidth);
              const scale = (targetCssWidth / viewport.width) * devicePixelRatio;
              const renderViewport = page.getViewport({ scale });
              const canvas = document.createElement("canvas");
              canvas.width = Math.round(renderViewport.width);
              canvas.height = Math.round(renderViewport.height);
              canvas.style.maxWidth = "90vw";
              canvas.style.height = "auto";
              canvas.style.boxShadow = "0 2px 8px rgba(0,0,0,0.12)";
              canvas.style.borderRadius = "4px";
              canvas.style.background = "#fff";
              const ctx = canvas.getContext("2d");
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              await page.render({ canvasContext: ctx, viewport: renderViewport }).promise;
              const label = document.createElement("div");
              label.textContent = `Page ${p} / ${pdf.numPages}`;
              label.style = "font-size:12px;color:#333;align-self:flex-start;margin-left:8px;";
              contentWrapper.appendChild(label);
              contentWrapper.appendChild(canvas);
            }
            return;
          } catch (err) {
            console.error("DEBUG_PREVIEW", "PDF render failed:", err);
            loadingIndicator.textContent = "Failed to render PDF. Falling back to embed.";
          }
        }
        const embed = document.createElement("embed");
        embed.src = src;
        embed.type = type || "application/octet-stream";
        embed.style.width = "80vw";
        embed.style.height = "70vh";
        box.insertBefore(embed, controls);
      } catch (err) { console.error("DEBUG_PREVIEW", "openPreview error:", err); }
    }

    function closePreview() {
      const overlay = document.getElementById("preview-overlay");
      if (!overlay) return;
      try {
        if (overlay._cleanup) overlay._cleanup();
        if (history.state && history.state.preview) { try { history.back(); } catch (e) { } }
      } finally { overlay.remove(); }
    }

    // ======================================================
    // =============== File Upload & Crop ===================
    // ======================================================
    function handleFileUpload() {
      const fileInput = document.getElementById("fileInput");
      const file = fileInput.files && fileInput.files[0];
      if (!file || !currentRoom) { if (fileInput) fileInput.value = ""; return; }
      const reader = new FileReader();
      reader.onload = () => {
        const overlay = document.createElement("div");
        overlay.id = "file-preview";
        overlay.style = `position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.9);display:flex;align-items:center;justify-content:center;flex-direction:column;z-index:9999;`;
        if (file.type.startsWith("image/")) {
          overlay.innerHTML = `<div style="background:#222;padding:15px;border-radius:12px;max-width:90%;max-height:90%;display:flex;flex-direction:column;align-items:center;">
        <div style="width:80vmin;height:80vmin;position:relative;">
          <img id="crop-image" src="${reader.result}" style="max-width:100%;max-height:100%;border-radius:8px;display:block;margin:auto;">
        </div>
        <div style="margin-top:12px;display:flex;gap:12px;flex-wrap:wrap;justify-content:center;">
          <button onclick="rotateCrop(-90)" style="background:#34495e;color:#fff;padding:6px 12px;border:none;border-radius:4px;cursor:pointer;">⟲ Rotate</button>
          <button onclick="rotateCrop(90)" style="background:#34495e;color:#fff;padding:6px 12px;border:none;border-radius:4px;cursor:pointer;">⟳ Rotate</button>
          <button onclick="closeFilePreview()" style="background:#e74c3c;color:#fff;padding:6px 12px;border:none;border-radius:4px;cursor:pointer;">Cancel</button>
          <button onclick="applyCropAndSend('${file.name}','${file.type}')" style="background:#27ae60;color:#fff;padding:6px 12px;border:none;border-radius:4px;cursor:pointer;">Send</button>
        </div>
      </div>`;
        } else if (file.type.startsWith("video/")) {
          overlay.innerHTML = `<div style="background:#222;padding:15px;border-radius:12px;max-width:90%;max-height:90%;display:flex;flex-direction:column;align-items:center;">
        <video controls style="width:80vw;max-height:80vh;border-radius:8px;"><source src="${reader.result}" type="${file.type}">Your browser does not support the video tag.</video>
        <div style="margin-top:12px;display:flex;gap:12px;">
          <button onclick="closeFilePreview()" style="background:#e74c3c;color:#fff;padding:6px 12px;border:none;border-radius:4px;cursor:pointer;">Cancel</button>
          <button onclick="confirmFileSend('${reader.result}','${file.name}','${file.type}')" style="background:#27ae60;color:#fff;padding:6px 12px;border:none;border-radius:4px;cursor:pointer;">Send</button>
        </div>
      </div>`;
        } else if (file.type === "application/pdf") {
          const pdfUrl = URL.createObjectURL(file);
          const pdfjsLib = window["pdfjs-dist/build/pdf"];
          pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";
          const loadingTask = pdfjsLib.getDocument(pdfUrl);
          loadingTask.promise.then(async (pdf) => {
            const page = await pdf.getPage(1);
            const viewport = page.getViewport({ scale: 1.5 });
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            await page.render({ canvasContext: ctx, viewport }).promise;
            overlay.innerHTML = `<div style="background:#222;padding:15px;border-radius:12px;max-width:95%;max-height:95%;display:flex;flex-direction:column;align-items:center;">
          <canvas id="pdf-canvas" style="max-width:90vw;max-height:80vh;border-radius:8px;object-fit:contain"></canvas>
          <div style="margin-top:8px;color:#fff;">📄 ${file.name}</div>
          <div style="margin-top:12px;display:flex;gap:12px;">
            <button onclick="closeFilePreview()" style="background:#e74c3c;color:white;padding:6px 12px;border:none;border-radius:4px;cursor:pointer;">Cancel</button>
            <button onclick="confirmFileSend('${reader.result}','${file.name}','${file.type}')" style="background:#27ae60;color:white;padding:6px 12px;border:none;border-radius:4px;cursor:pointer;">Send</button>
          </div>
        </div>`;
            const previewCanvas = overlay.querySelector("#pdf-canvas");
            previewCanvas.width = canvas.width;
            previewCanvas.height = canvas.height;
            previewCanvas.getContext("2d").drawImage(canvas, 0, 0);
          });
        } else {
          overlay.innerHTML = `<div style="background:#222;padding:15px;border-radius:12px;max-width:90%;max-height:90%;display:flex;flex-direction:column;align-items:center;">
        <embed src="${reader.result}" type="${file.type}" style="width:80vw;height:70vh;border-radius:8px;">
        <div style="margin-top:12px;display:flex;gap:12px;">
          <button onclick="closeFilePreview()" style="background:#e74c3c;color:white;padding:6px 12px;border:none;border-radius:4px;cursor:pointer;">Cancel</button>
          <button onclick="confirmFileSend('${reader.result}','${file.name}','${file.type}')" style="background:#27ae60;color:white;padding:6px 12px;border:none;border-radius:4px;cursor:pointer;">Send</button>
        </div>
      </div>`;
        }
        document.body.appendChild(overlay);
        if (file.type.startsWith("image/")) {
          const image = document.getElementById("crop-image");
          image.onload = () => {
            if (window._cropper) window._cropper.destroy();
            window._rotation = 0;
            window._cropper = new Cropper(image, {
              viewMode: 2, autoCropArea: 1, responsive: true, rotatable: true,
              ready() {
                const canvas = this.cropper.getCanvasData();
                this.cropper.setCropBoxData({ width: canvas.width, height: canvas.height });
              },
            });
          };
        }
      };
      reader.readAsDataURL(file);
    }

    function rotateCrop(deg) {
      const cropper = window._cropper;
      if (!cropper) return;
      window._rotation = ((window._rotation || 0) + deg) % 360;
      cropper.reset();
      cropper.rotateTo(window._rotation);
      setTimeout(() => { fitFullImageCrop(); }, 80);
    }

    function fitFullImageCrop() {
      const cropper = window._cropper;
      if (!cropper) return;
      const canvas = cropper.getCanvasData();
      cropper.setCropBoxData({ width: canvas.width, height: canvas.height });
    }

    function applyCropAndSend(filename, mimetype) {
      if (!window._cropper) return;
      const canvas = window._cropper.getCroppedCanvas({ maxWidth: 1920, maxHeight: 1920, fillColor: "#fff" });
      if (!canvas) return;
      canvas.toBlob((blob) => {
        const reader = new FileReader();
        reader.onloadend = () => { confirmFileSend(reader.result, filename, mimetype); };
        reader.readAsDataURL(blob);
      }, mimetype);
    }

    function confirmFileSend(data, filename, mimetype) {
      const nowTs = new Date().toISOString();
      lastPersistedTs = nowTs;
      try {
        localStorage.setItem("chatState", JSON.stringify({ username: currentName, room: currentRoom, lastTs: lastPersistedTs }));
      } catch (e) { /* ignore */ }
      socket.emit("file", { room: currentRoom, sender: currentName, filename, mimetype, data });
      closeFilePreview();
      document.getElementById("fileInput").value = "";
    }

    function closeFilePreview() {
      const overlay = document.getElementById("file-preview");
      if (overlay) overlay.remove();
      document.getElementById("fileInput").value = "";
      if (window._cropper) {
        window._cropper.destroy();
        window._cropper = null;
      }
      window._rotation = 0;
    }

    // ======================================================
    // =============== User List Management =================
    // ======================================================
    function updateUserList(data) {
      if (!currentRoom || data.room !== currentRoom) return;
      const list = document.getElementById("user-list");
      const seen = new Set();
      const existing = new Map();
      list.querySelectorAll("li").forEach((li) => existing.set(li.getAttribute("data-name"), li));
      const sortedUsers = [...data.users].sort((a, b) => {
        if (a.active === b.active) return a.name.localeCompare(b.name);
        return a.active ? -1 : 1;
      });
      sortedUsers.forEach((u) => {
        if (seen.has(u.name)) return;
        seen.add(u.name);
        const color = u.active ? "#25d366" : "#e74c3c";
        const displayName = u.name === currentName ? `${u.name} (Me)` : u.name;
        let li = existing.get(u.name);
        if (li) {
          li.innerHTML = `<span style="color:${color}">●</span> ${displayName}`;
          existing.delete(u.name);
        } else {
          li = document.createElement("li");
          li.setAttribute("data-name", u.name);
          li.className = "fade-in";
          li.innerHTML = `<span style="color:${color}">●</span> ${displayName}`;
          list.appendChild(li);
        }
        if (u.name === currentAdmin) {
          const adminBadge = document.createElement('span');
          adminBadge.className = 'admin-badge';
          adminBadge.textContent = ' 👑';
          adminBadge.style.marginLeft = '5px';
          adminBadge.style.color = '#ffd700';
          li.appendChild(adminBadge);
        }
      });
      setTimeout(cleanupEncryptionSessions, 1000);
      existing.forEach((li) => {
        li.classList.add("fade-out");
        setTimeout(() => li.remove(), 300);
      });
    }

    function handleRoomDestroyed(data) {
      const destroyedRoom = data.room;
      if (joinedRooms.has(destroyedRoom)) joinedRooms.delete(destroyedRoom);
      if (joinedRoomsByUser[currentName]) {
        joinedRoomsByUser[currentName] = joinedRoomsByUser[currentName].filter((r) => r !== destroyedRoom);
        localStorage.setItem("joinedRoomsByUser", JSON.stringify(joinedRoomsByUser));
      }
      if (currentRoom === destroyedRoom) {
        currentRoom = "";
        document.getElementById("messages").innerHTML = "";
        document.getElementById("user-list").innerHTML = "";
        document.getElementById("chat-container").style.display = "none";
        document.getElementById("input-area").style.display = "none";
        document.getElementById("intro").style.display = "block";
      }
      renderJoinedRooms();
    }

    function handleRoomCleared(data) {
      if (currentRoom === data.room) {
        document.getElementById("messages").innerHTML = "";
        addMessage({ sender: "System", text: data.message, ts: new Date().toISOString() });
        lastPersistedTs = null;
      }
    }

    // ======================================================
    // =============== Room Actions =========================
    // ======================================================
    window.clearRoom = async function clearRoom() {
      if (!currentRoom) { alert("Join a room first!"); return; }
      if (currentName !== currentAdmin) { showAdminActionError("Only room admin can clear the room"); return; }
      if (!joinedRooms.has(currentRoom)) { showAdminActionError("You must be in the room to clear it"); return; }
      try {
        const res = await fetch(`${API_BASE}/clear/${encodeURIComponent(currentRoom)}`, {
          method: "DELETE", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ user: currentName, room: currentRoom }), cache: "no-store",
        });
        const data = await res.json();
        if (!res.ok) { showAdminActionError(data?.error || `Failed to clear room: ${res.status}`); return; }
        const messages = document.getElementById("messages");
        const successDiv = document.createElement("div");
        successDiv.className = "msg system";
        successDiv.style.background = "#27ae60";
        successDiv.style.color = "white";
        successDiv.innerHTML = `<strong>✅ Room Cleared</strong><br>${data.message}<br><small>${new Date().toLocaleString()}</small>`;
        messages.appendChild(successDiv);
        messages.scrollTo({ top: messages.scrollHeight, behavior: "smooth" });
        setTimeout(() => { if (successDiv.parentNode) successDiv.remove(); }, 4000);
      } catch (err) {
        console.error("❌ clearRoom error:", err);
        showAdminActionError("Network error: " + err.message);
      }
    };

    window.destroyRoom = async function destroyRoom() {
      if (!currentRoom) { alert("Join a room first!"); return; }
      if (currentName !== currentAdmin) { showAdminActionError("Only room admin can destroy the room"); return; }
      if (!joinedRooms.has(currentRoom)) { showAdminActionError("You must be in the room to destroy it"); return; }
      if (!confirm(`Are you sure you want to destroy room "${currentRoom}"? This action cannot be undone!`)) return;
      try {
        const res = await fetch(`${API_BASE}/destroy/${encodeURIComponent(currentRoom)}`, {
          method: "DELETE", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ user: currentName, room: currentRoom }),
        });
        const data = await res.json();
        if (!res.ok) { showAdminActionError(data?.error || `Failed to destroy room: ${res.status}`); return; }
        unsubscribeUser(currentName, currentRoom);
        document.getElementById("messages").innerHTML = "";
        addMessage({ sender: "System", text: "✅ Room destroyed successfully. All messages and user data cleared.", ts: new Date().toISOString() });
        setTimeout(() => {
          lastPersistedTs = null;
          Storage.remove("chat_name");
          Storage.remove("chat_room");
          joinedRooms.delete(currentRoom);
          currentRoom = "";
          document.getElementById("user-list").innerHTML = "";
          document.getElementById("chat-container").style.display = "none";
          document.getElementById("input-area").style.display = "none";
          document.getElementById("intro").style.display = "block";
          document.getElementById("messages").style.display = "none";
        }, 2000);
      } catch (err) {
        console.error("❌ destroyRoom error:", err);
        showAdminActionError("Network error: " + err.message);
      }
    };

    async function leaveRoom() {
      if (!currentRoom) { alert("You are not in a room!"); return; }
      intentionalLeave = true;
      const leftRoom = currentRoom;
      const savedToken = localStorage.getItem("fcm_token");
      if (socket && socket.connected) {
        socket.emit("leave", { room: currentRoom, sender: currentName, reason: "leave" });
      }
      document.getElementById("input").disabled = true;
      document.getElementById("send").disabled = true;
      document.getElementById("attach").disabled = true;
      addMessage({ sender: "System", text: `YOU LEFT FROM ROOM ${leftRoom}`, ts: new Date().toISOString() });
      lastPersistedTs = null;
      joinedRooms.delete(currentRoom);
      if (joinedRoomsByUser[currentName]) {
        joinedRoomsByUser[currentName] = joinedRoomsByUser[currentName].filter((r) => r !== currentRoom);
        localStorage.setItem("joinedRoomsByUser", JSON.stringify(joinedRoomsByUser));
      }
      if (savedToken) {
        try {
          await fetch("/api/unregister-fcm", {
            method: "POST", headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ token: savedToken, user: currentName, room: currentRoom }),
          });
        } catch (err) { console.error("❌ Failed to unregister FCM token:", err); }
      }
      try { await unsubscribeUser(currentName, currentRoom); } catch (err) { console.error("❌ Failed to unsubscribe WebPush:", err); }
      const userRooms = joinedRoomsByUser[currentName] || [];
      if (userRooms.length === 0) {
        Object.keys(roomLockStates).forEach((room) => { if (roomLockStates[room]) Storage.remove(`room_lock_${room}`); });
      }
      Storage.remove("pending_room");
      Storage.remove("pending_name");
      renderJoinedRooms();
      currentRoom = "";
      Storage.remove("chat_name");
      Storage.remove("chat_room");
      document.getElementById("user-list").innerHTML = "";
      document.getElementById("chat-container").style.display = "block";
      document.getElementById("input-area").style.display = "none";
      document.getElementById("messages").style.display = "block";
      document.getElementById("roomLockToggle").checked = false;
      updateLockUI(false);
      setTimeout(() => {
        if (socket && joinedRooms.size === 0) {
          socket.disconnect();
          socket = null;
        }
        intentionalLeave = false;
      }, 1000);
    }

    // ======================================================
    // =============== Room Lock Functions ==================
    // ======================================================
    window.toggleRoomLock = async function () {
      if (!currentRoom) { alert("Join a room first!"); document.getElementById("roomLockToggle").checked = false; return; }
      if (currentName !== currentAdmin) {
        alert("Only room admin can lock/unlock the room");
        document.getElementById("roomLockToggle").checked = !document.getElementById("roomLockToggle").checked;
        return;
      }
      const isLocked = document.getElementById("roomLockToggle").checked;
      try {
        const response = await fetch(`${API_BASE}/room-lock/${encodeURIComponent(currentRoom)}`, {
          method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ locked: isLocked, user: currentName }),
        });
        if (!response.ok) {
          if (response.status === 403) {
            const errorData = await response.json();
            alert(errorData.error);
            document.getElementById("roomLockToggle").checked = !isLocked;
            return;
          }
          throw new Error("Failed to update room lock");
        }
        const data = await response.json();
        roomLockStates[currentRoom] = isLocked;
        updateLockUI(isLocked);
        if (socket) {
          socket.emit("room_lock_changed", { room: currentRoom, locked: isLocked, lockedBy: currentName });
        }
      } catch (err) {
        console.error("❌ toggleRoomLock error:", err);
        document.getElementById("roomLockToggle").checked = !isLocked;
        alert("Failed to update room lock");
      }
    };

    async function checkRoomLockStatus(room) {
      try {
        const response = await fetch(`${API_BASE}/room-lock/${encodeURIComponent(room)}`);
        if (response.ok) {
          const data = await response.json();
          roomLockStates[room] = data.locked;
          return data.locked;
        }
      } catch (err) { console.warn("Failed to check room lock status:", err); }
      return false;
    }

    function loadRoomLockState(room) {
      const saved = Storage.get(`room_lock_${room}`);
      return saved === "true";
    }

    function saveRoomLockState(room, isLocked) {
      Storage.set(`room_lock_${room}`, isLocked.toString());
    }

    async function getRoomUsers(room) {
      try {
        const response = await fetch(`${API_BASE}/room-users/${encodeURIComponent(room)}`);
        if (response.ok) {
          const data = await response.json();
          return data.users || [];
        }
      } catch (err) { console.warn("Failed to get room users:", err); }
      return [];
    }

    window.approveJoinRequest = function (room, user) {
      if (!socket) return;
      socket.emit("approve_join_request", { room: room, user: user, admin: currentName }, (response) => {
        if (response && response.success) {
          const notifications = document.querySelectorAll(`[id^="join-request-${user}"]`);
          notifications.forEach(notification => notification.remove());
          addMessage({ sender: "System", text: response.message, ts: new Date().toISOString() });
        } else alert(response?.error || "Failed to approve request");
      });
    };

    window.rejectJoinRequest = function (room, user) {
      if (!socket) return;
      socket.emit("reject_join_request", { room: room, user: user, admin: currentName }, (response) => {
        if (response && response.success) {
          const notifications = document.querySelectorAll(`[id^="join-request-${user}"]`);
          notifications.forEach(notification => notification.remove());
          addMessage({ sender: "System", text: response.message, ts: new Date().toISOString() });
        } else alert(response?.error || "Failed to reject request");
      });
    };

    // ======================================================
    // =============== Event Listeners ======================
    // ======================================================
    document.addEventListener("visibilitychange", () => sendActive(!document.hidden));
    window.addEventListener("focus", () => sendActive(true));
    window.addEventListener("blur", () => sendActive(false));
    window.addEventListener("offline", () => { if (socket && socket.connected) socket.disconnect(); });
    let reconnectTimer;
    window.addEventListener("online", () => {
      clearTimeout(reconnectTimer);
      reconnectTimer = setTimeout(() => {
        if (socket && !socket.connected && currentRoom && currentName) socket.connect();
        else if (socket && socket.connected) fetchUnreadCounts();
      }, 300);
    });

    // ======================================================
    // =============== Initialization =======================
    // ======================================================
    window.addEventListener("load", async () => {
      await initializeEncryption();
      await requestNotificationPermission();
      const savedName = Storage.get("chat_name");
      const savedRoom = Storage.get("chat_room");
      if (savedName && savedRoom) {
        try {
          const roomStatus = await checkRoomStatus(savedRoom, savedName);
          if (roomStatus.destroyed || roomStatus.was_destroyed) {
            showDestroyedRoomAlert(savedRoom, roomStatus.time_remaining);
            Storage.remove("chat_name");
            Storage.remove("chat_room");
            if (joinedRoomsByUser[savedName]) {
              joinedRoomsByUser[savedName] = joinedRoomsByUser[savedName].filter((r) => r !== savedRoom);
              localStorage.setItem("joinedRoomsByUser", JSON.stringify(joinedRoomsByUser));
            }
            document.getElementById("intro").style.display = "block";
            return;
          }
          const isLocked = await checkRoomLockStatus(savedRoom);
          roomLockStates[savedRoom] = isLocked;
          if (isLocked) {
            const roomUsers = await getRoomUsers(savedRoom);
            const isExistingUser = roomUsers.includes(savedName);
            if (!isExistingUser) {
              alert(`Room "${savedRoom}" is locked. You cannot join at this time.`);
              document.getElementById("intro").style.display = "block";
              return;
            }
          }
          document.getElementById("name").value = savedName;
          document.getElementById("room").value = savedRoom;
          joinRoom({ preserveMessages: true });
        } catch (err) {
          console.error("Auto-join blocked due to status check failure:", err);
          Storage.remove("chat_name");
          Storage.remove("chat_room");
          document.getElementById("intro").style.display = "block";
        }
      } else document.getElementById("intro").style.display = "block";
    });

    // ======================================================
    // =============== Capacitor Push Notifications =========
    // ======================================================
    document.addEventListener("DOMContentLoaded", async () => {
      const { PushNotifications } = Capacitor.Plugins;
      if (!PushNotifications) { console.error("❌ PushNotifications plugin not available"); return; }
      let permStatus = await PushNotifications.requestPermissions();
      if (permStatus.receive === "granted") await PushNotifications.register();
      PushNotifications.addListener("registration", async (token) => {
        try {
          const user = localStorage.getItem("chat_name") || "guest";
          const room = localStorage.getItem("chat_room") || null;
          await fetch("https://realtime-chat-1mv3.onrender.com/api/register-fcm", {
            method: "POST", headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ token: token.value, user, room }),
          });
          localStorage.setItem("fcm_token", token.value);
        } catch (err) { console.error("❌ Failed to send token:", err); }
      });
      PushNotifications.addListener("registrationError", (err) => { console.error("❌ Registration error:", err.error); });
      PushNotifications.addListener("pushNotificationReceived", (notification) => { });
      PushNotifications.addListener("pushNotificationActionPerformed", (action) => { });
      window.clearNotifications = async () => {
        try { await PushNotifications.removeAllDeliveredNotifications(); } catch (err) { console.error("❌ Failed to clear notifications:", err); }
      };
    });

    // ======================================================
    // =============== Auto Update Alert ====================
    // ======================================================
    (async function () {
      const API_BASE = "https://realtime-chat-1mv3.onrender.com";
      let overlay = null, fadeOutTimer = null;
      async function getAppVersion() {
        if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.App) {
          try {
            const info = await window.Capacitor.Plugins.App.getInfo();
            console.log("📱 DEBUG - Capacitor App Info:", info);
            return { code: parseInt(info.build || "13"), name: parseFloat(info.version || "7.5") };
          } catch (error) { console.warn("Could not get app info:", error); }
        }
        if (window.cordova && window.cordova.getAppVersion) {
          try {
            const appVersion = await new Promise((resolve, reject) => { cordova.getAppVersion.getVersionNumber(resolve, reject); });
            const versionCode = await new Promise((resolve, reject) => { cordova.getAppVersion.getVersionCode(resolve, reject); });
            return { code: parseInt(versionCode || "13"), name: parseFloat(appVersion || "7.5") };
          } catch (error) { console.warn("Could not get Cordova app info:", error); }
        }
        console.log("🌐 Using fallback version (web or plugin unavailable)");
        return { code: 13, name: 7.5 };
      }
      async function getVersionInfo() {
        try {
          const response = await fetch(API_BASE + "/api/app-version?_=" + Date.now(), { cache: "no-store" });
          if (!response.ok) { console.warn("Failed to fetch version info"); return null; }
          return await response.json();
        } catch (error) { console.warn("Version check failed:", error); return null; }
      }
      function showUpdateBox(currentVersion, currentCode, latestVersion) {
        if (overlay) return;
        overlay = document.createElement("div");
        overlay.style = `position:fixed;inset:0;background:rgba(0,0,0,0.6);backdrop-filter:blur(6px);display:flex;justify-content:center;align-items:center;z-index:99999;font-family:'Segoe UI',Roboto,Arial,sans-serif;opacity:1;transition:opacity 0.6s ease;`;
        const box = document.createElement("div");
        box.style = `background:rgba(20,20,20,0.95);color:#f5f5f5;border-radius:16px;padding:30px 24px;width:90%;max-width:360px;text-align:center;box-shadow:0 10px 25px rgba(0,0,0,0.4),inset 0 0 0 1px rgba(255,255,255,0.05);animation:popIn 0.5s cubic-bezier(.16,1,.3,1);`;
        box.innerHTML = `
      <div style="display:flex;flex-direction:column;align-items:center;gap:14px;">
        <div style="background:#25d36622;border-radius:50%;padding:14px;"><span style="font-size:36px;color:#25d366;">⬆️</span></div>
        <h2 style="font-size:1.5em;color:#25d366;margin:0;">Update Available</h2>
        <p style="font-size:1em;line-height:1.6;color:#ccc;margin:0 0 12px;">You're using version <b>v${currentVersion}</b>⚠️<br>A newer version <b>v${latestVersion}</b> available. Update now to enjoy the latest features and improvements!</p>
        <a href="https://indusapp.store/3ylw7f8l" target="_blank" style="background:linear-gradient(90deg,#25d366,#128c7e);color:#fff;text-decoration:none;padding:10px 26px;border-radius:8px;font-weight:600;letter-spacing:0.4px;display:inline-block;box-shadow:0 3px 8px rgba(0,0,0,0.3);transition:transform 0.2s,box-shadow 0.2s;" onmouseover="this.style.transform='scale(1.05)';this.style.boxShadow='0 5px 12px rgba(0,0,0,0.4)'" onmouseout="this.style.transform='scale(1)';this.style.boxShadow='0 3px 8px rgba(0,0,0,0.3)'">🔄 Update Now</a>
      </div>`;
        if (!document.querySelector("#popin-animation")) {
          const style = document.createElement("style");
          style.id = "popin-animation";
          style.textContent = `@keyframes popIn{0%{opacity:0;transform:scale(0.9);}100%{opacity:1;transform:scale(1);}}`;
          document.head.appendChild(style);
        }
        overlay.appendChild(box);
        document.body.appendChild(overlay);
      }
      function fadeOutOverlay() {
        if (!overlay) return;
        overlay.style.opacity = "0";
        clearTimeout(fadeOutTimer);
        fadeOutTimer = setTimeout(() => { overlay.remove(); overlay = null; }, 800);
      }
      async function checkVersion() {
        try {
          const appVersion = await getAppVersion();
          const appVersionCode = appVersion.code;
          const appVersionName = appVersion.name;
          const versionInfo = await getVersionInfo();
          if (!versionInfo) return;
          const minRequiredCode = versionInfo.min_required_version.code;
          const minRequiredName = parseFloat(versionInfo.min_required_version.name);
          const latestVersionName = versionInfo.current_version.name;
          console.log("🔍 Version Check:"); console.log(" - App Version:", appVersionCode, appVersionName);
          console.log(" - Min Required:", minRequiredCode, minRequiredName); console.log(" - Latest Available:", latestVersionName);
          const outdated = appVersionCode < minRequiredCode || appVersionName < minRequiredName;
          if (outdated && !overlay) {
            console.log("🚨 Showing update alert - app is outdated");
            showUpdateBox(appVersionName, appVersionCode, latestVersionName);
          } else if (!outdated && overlay) {
            console.log("✅ App is up to date - hiding alert");
            fadeOutOverlay();
          } else console.log("✅ App is up to date");
        } catch (err) { console.warn("Version check failed:", err); }
      }
      document.addEventListener("DOMContentLoaded", async function () {
        setTimeout(async () => { await checkVersion(); }, 1000);
        setInterval(checkVersion, 130000);
      });
    })();

    // ======================================================
    // =============== Chat Title Reload ====================
    // ======================================================
    document.addEventListener('DOMContentLoaded', function () {
      const chatTitle = document.getElementById('chat-title');
      if (chatTitle) {
        chatTitle.addEventListener('click', function () {
          console.log('💬 Chattrix title clicked - reloading page...');
          window.location.reload();
        });
        chatTitle.style.cursor = 'pointer';
        chatTitle.title = 'Click to reload the app';
        console.log('💬 Chattrix reload handler initialized');
      }
    });
  </script>

  <script type="module">
    // ======================================================
    // =============== Capacitor Storage Module =============
    // =============== Capacitor Storage Module =============
    // ======================================================
    import { Storage } from "@capacitor/storage";
    import { PushNotifications, LocalNotifications } from "@capacitor/push-notifications";
    async function saveChatState(username, room, lastTs) {
      await Storage.set({ key: "chatState", value: JSON.stringify({ username, room, lastTs }) });
    }
    async function loadChatState() {
      const { value } = await Storage.get({ key: "chatState" });
      return value ? JSON.parse(value) : null;
    }
    const API_BASE_CAP = "https://realtime-chat-1mv3.onrender.com";
    const state = await loadChatState();
    if (state) {
      try {
        const res = await fetch(`${API_BASE}/destroyed_rooms`, { cache: "no-store" });
        const json = await res.json();
        const destroyed = json.destroyed || [];
        if (!destroyed.includes(state.room)) {
          const fcmToken = localStorage.getItem("fcm_token") || null;
          socket.emit("join", { room: state.room, sender: state.username, lastTs: state.lastTs, fcmToken });
        } else await Storage.remove({ key: "chatState" });
      } catch (err) { console.warn("Failed to check destroyed rooms on startup:", err); }
    }
  </script>
</body>

</html>